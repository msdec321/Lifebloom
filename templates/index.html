<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lifebloom - A Restoration Druid Analysis Tool</title>
    <link rel="icon" type="image/jpeg" href="/static/icons/lifebloom.jpg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #262626;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            color: #eee;
            display: flex;
        }

        .sidebar {
            width: 200px;
            background: #1d1f1c;
            border-right: 2px solid #2a3f5f;
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .sidebar-tab {
            padding: 15px 25px;
            cursor: pointer;
            color: #bebeb1;
            font-weight: 600;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .sidebar-tab:hover {
            background: #262626;
            color: #fff;
        }

        .sidebar-tab.active {
            background: #262626;
            color: #fff;
            border-left-color: #667eea;
        }

        .main-content {
            margin-left: 200px;
            flex: 1;
            padding: 20px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .druid-text {
            color: #DE772A;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s;
            border: 1px solid #2a3f5f;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
            border-color: #667eea;
        }

        .stat-card h3 {
            color: #bebeb1;
            font-size: 0.9em;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .table-container {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            overflow-x: auto;
            border: 1px solid #2a3f5f;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .table-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #bebeb1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .filtered-count {
            font-size: 0.9em;
            color: #DE772A;
            font-weight: 500;
        }

        .table-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-controls label {
            color: #eee;
            font-weight: 600;
        }

        .table-controls input {
            padding: 8px 12px;
            border: 1px solid #3a3d3a;
            border-radius: 5px;
            font-size: 1em;
            width: 80px;
            background: #2a2d2a;
            color: #bebeb1;
        }

        .table-controls input:focus {
            outline: none;
            border-color: #4a4d4a;
            background: #3a3d3a;
        }

        .table-controls button {
            padding: 8px 16px;
            background: #2a2d2a;
            color: #bebeb1;
            border: 1px solid #3a3d3a;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .table-controls button:hover {
            background: #3a3d3a;
            color: #fff;
            border-color: #4a4d4a;
        }

        .collapse-btn {
            background: #2a2d2a;
            border: 1px solid #3a3d3a;
            border-radius: 5px;
            padding: 8px 16px;
            color: #bebeb1;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .collapse-btn:hover {
            background: #3a3d3a;
            color: #fff;
            border-color: #4a4d4a;
        }

        .table-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
        }

        .table-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background: #16213e;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #8b9dc3;
        }

        .chart-container canvas {
            max-height: 400px;
        }

        .chart-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .chart-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .chart-collapse-btn {
            background: #2a3f5f;
            color: #8b9dc3;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .chart-collapse-btn:hover {
            background: #3a4f6f;
            color: #fff;
        }

        #rotationChartContent {
            height: 400px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #2a2d2a;
            color: #bebeb1;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #2a3f5f;
            color: #eee;
        }

        th {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 0.5px;
        }

        tbody tr:hover {
            background-color: #1f2d47;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #8b9dc3;
            font-size: 1.2em;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-yes {
            background-color: #10b981;
            color: white;
        }

        .badge-no {
            background-color: #ef4444;
            color: white;
        }

        .controls {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .controls-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #bebeb1;
            margin-bottom: 20px;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .filter-section-title {
            color: #8b9dc3;
            font-weight: 600;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a3f5f;
            margin-bottom: 5px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filter-item label {
            font-weight: 600;
            color: #eee;
            min-width: 120px;
            font-size: 0.9em;
        }

        .filter-item select,
        .filter-item input {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            font-size: 0.9em;
            background: #2d2d2d;
            color: #fff;
            min-width: 0;
        }

        .filter-item select {
            cursor: pointer;
        }

        .filter-item select:focus,
        .filter-item input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #667eea40;
            border-color: #667eea;
        }

        .healer-comp-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .region-checkboxes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 8px;
            max-width: 150px;
        }

        .region-checkboxes label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: #eee;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .region-checkboxes input[type="checkbox"] {
            cursor: pointer;
        }

        .icon-buttons {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 30px;
        }

        .icon-button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .icon-label {
            color: #39c07f;
            font-size: 0.9em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .icon-button {
            background: #16213e;
            border: 2px solid #2a3f5f;
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-button:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.3);
        }

        .icon-button.active {
            border-color: #667eea;
            background: #0f3460;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .icon-button img {
            width: 44px;
            height: 44px;
            border-radius: 5px;
        }

        .notice-banner {
            background: #1d1f1c;
            border: 1px solid #2a3f5f;
            border-radius: 10px;
            padding: 20px 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            max-width: 1100px;
            margin-left: auto;
            margin-right: auto;
        }

        .notice-banner h3 {
            color: #bebeb1;
            font-size: 1.1em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .notice-banner p {
            color: #c5d0e6;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .notice-banner p:last-child {
            margin-bottom: 0;
        }

        .notice-banner .signature {
            color: #8b9dc3;
            font-style: italic;
            margin-top: 15px;
        }

        /* Theorycraft Section Styles */
        .theorycraft-section {
            background: #16213e;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .theorycraft-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }

        .theorycraft-header:hover {
            background: rgba(255,255,255,0.02);
        }

        .theorycraft-content {
            padding: 0 25px 25px 25px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
        }

        .theorycraft-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .theorycraft-content h3 {
            color: #bebeb1;
            margin-top: 1.5em;
        }

        .theorycraft-content h3:first-child {
            margin-top: 0;
        }

        .theorycraft-content h4 {
            color: #8b9dc3;
            margin-top: 1.2em;
        }

        .theorycraft-content h5 {
            color: #8b9dc3;
            margin-top: 1em;
        }

        .theorycraft-content p {
            color: #c5d0e6;
            line-height: 1.6;
            margin-bottom: 1em;
        }

        .theorycraft-content ul {
            color: #c5d0e6;
            line-height: 1.6;
            margin-bottom: 1em;
        }

        .theorycraft-content table {
            background: #0a0d0a;
            border: 1px solid #2a3f5f;
        }

        .theorycraft-content table th {
            background: #1a1d2a;
        }

        .theorycraft-content table tr:hover {
            background: rgba(255,255,255,0.03);
        }

        .section-divider {
            border: none;
            border-top: 1px solid #2a3f5f;
            margin: 25px 0;
        }

        .region-grid {
            display: grid;
            grid-template-columns: repeat(2, auto);
            gap: 5px 15px;
            margin-left: 5px;
        }

        .region-grid label {
            cursor: pointer;
            display: flex;
            align-items: center;
        }

        .region-grid input {
            margin: 0;
            cursor: pointer;
        }

        .about-section {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px 30px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .about-section h2 {
            color: #bebeb1;
            font-size: 1.3em;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .about-section p {
            color: #c5d0e6;
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .about-section.justified p {
            text-align: justify;
        }

        .about-section p:last-child {
            margin-bottom: 0;
        }

        .author-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .author-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid #667eea;
            object-fit: cover;
        }

        .author-name {
            color: #fff;
            font-size: 1.5em;
            font-weight: 600;
        }

        .contact-links {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .contact-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #0f3460;
            border: 1px solid #2a3f5f;
            border-radius: 6px;
            color: #c5d0e6;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
        }

        .contact-link:hover {
            border-color: #667eea;
            background: #1a3f6f;
            color: #fff;
        }

        .contact-link.discord {
            cursor: default;
        }

        .author-section {
            display: flex;
            gap: 25px;
        }

        .author-section .author-avatar {
            flex-shrink: 0;
        }

        .author-content {
            flex: 1;
        }

        .author-content h2 {
            margin-top: 0;
        }

        .about-section ul {
            color: #c5d0e6;
            line-height: 1.7;
            margin: 15px 0;
            padding-left: 25px;
        }

        .about-section li {
            margin-bottom: 8px;
        }

        .about-section em {
            color: #667eea;
            font-style: italic;
        }

        /* Loading spinner */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #2a3f5f;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Healer class colors */
        .healer-druid { color: #FF7C0A; }
        .healer-paladin { color: #F48CBA; }
        .healer-priest-holy { color: #FFFFFF; }
        .healer-priest-disc { color: #FFFFFF; }
        .healer-shaman { color: #0070DD; }

        /* Tank class color */
        .tank-badge {
            display: inline-block;
            padding: 6px 12px;
            background: #0f3460;
            border: 1px solid #2a3f5f;
            border-radius: 5px;
            color: #C41E3A;
            font-weight: 600;
        }

        /* Data Dictionary styles */
        .data-dictionary {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .data-dictionary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .data-dictionary-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #bebeb1;
        }

        .data-dictionary-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out;
            opacity: 0;
            margin-top: 0;
        }

        .data-dictionary-content.expanded {
            max-height: 2000px;
            opacity: 1;
            margin-top: 20px;
        }

        .dict-category {
            margin-bottom: 25px;
        }

        .dict-category:last-child {
            margin-bottom: 0;
        }

        .dict-category-title {
            color: #8b9dc3;
            font-weight: 600;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a3f5f;
            margin-bottom: 15px;
        }

        .dict-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .dict-item {
            background: #262626;
            border-radius: 6px;
            padding: 12px 15px;
            border-left: 3px solid #667eea;
        }

        .dict-term {
            color: #DE772A;
            font-weight: 600;
            font-size: 0.95em;
            margin-bottom: 5px;
        }

        .dict-definition {
            color: #c5d0e6;
            font-size: 0.9em;
            line-height: 1.5;
        }

        /* Language Toggle Styles */
        .language-toggle {
            position: fixed;
            top: 15px;
            right: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
            background: #1d1f1c;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #2a3f5f;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .language-toggle span {
            color: #bebeb1;
            font-size: 0.85em;
            font-weight: 500;
        }

        .lang-btn {
            padding: 6px 12px;
            border: 1px solid #3a3d3a;
            background: #2a2d2a;
            color: #bebeb1;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .lang-btn:hover {
            background: #3a3d3a;
            color: #fff;
            border-color: #4a4d4a;
        }

        .lang-btn.active {
            background: #667eea;
            color: #fff;
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <!-- Language Toggle -->
    <div class="language-toggle">
        <span>Language:</span>
        <button class="lang-btn active" id="langEN" onclick="setLanguage('en')">EN</button>
        <button class="lang-btn" id="langZH" onclick="setLanguage('zh')">中文</button>
    </div>

    <div class="sidebar">
        <div class="sidebar-tab active" onclick="switchTab('analysis')">Analysis Tool</div>
        <div class="sidebar-tab" onclick="switchTab('report')">Report Analyzer</div>
        <div class="sidebar-tab" onclick="switchTab('theorycrafting')">Community Theorycrafting</div>
        <div class="sidebar-tab" onclick="switchTab('about')">About</div>
    </div>

    <div class="main-content">
        <!-- Analysis Tool Tab -->
        <div id="analysisTab" class="tab-content active">
            <div class="container">
                <h1 id="pageTitle">Lifebloom - A Restoration <span class="druid-text">Druid</span> Analysis Tool</h1>

                <div class="notice-banner">
                    <h3 data-i18n="notice.title">Notice</h3>
                    <p data-i18n="notice.welcome">Welcome to <span style="color: #39c07f; font-weight: 600;">Lifebloom</span>! This is an application that collects and structures TBC Resto Druid data from WarcraftLogs in order to help facilitate retrospective data analyses by and for the community. This app is still in development in preparation for the next iteration of TBC Classic.</p>
                    <p data-i18n="notice.moreInfo">For more information about the tool and how to contact the author, please check out the "About" tab. Thanks!</p>
                    <p class="signature">- Mercy</p>
                </div>

                <hr class="section-divider">

        <div class="icon-buttons">
            <div class="icon-button-container">
                <div class="icon-label" data-i18n="icons.deepResto">Deep Resto</div>
                <button class="icon-button" id="treeOfLifeBtn">
                    <img src="/static/icons/treeoflife.jpg" alt="Tree of Life">
                </button>
            </div>
            <div class="icon-button-container">
                <div class="icon-label" data-i18n="icons.dreamstate">Dreamstate</div>
                <button class="icon-button" id="dreamstateBtn">
                    <img src="/static/icons/dreamstate.jpg" alt="Dreamstate">
                </button>
            </div>
            <div class="icon-button-container">
                <div class="icon-label" data-i18n="icons.naturesGrace">Nature's Grace</div>
                <button class="icon-button" id="naturesGraceBtn">
                    <img src="/static/icons/naturesgrace.jpg" alt="Nature's Grace">
                </button>
            </div>
        </div>

        <div class="controls">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <div class="controls-title" style="margin-bottom: 0;">Filters</div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: #ddd; font-size: 0.9em;">
                        <input type="radio" name="dataSource" value="best" checked onchange="loadData()">
                        <span>Best report per player</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: #ddd; font-size: 0.9em;">
                        <input type="radio" name="dataSource" value="all" onchange="loadData()">
                        <span>All reports per player</span>
                    </label>
                </div>
            </div>
            <p style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 15px;">For descriptions of each variable in the dataset and a definition of Rotation, please see the Data Dictionary section below.</p>
            <div class="filter-grid">
                <!-- Fight Settings Section -->
                <div class="filter-section">
                    <div class="filter-section-title">Fight Settings</div>
                    <div class="filter-item">
                        <label for="dataset">Boss:</label>
                        <select id="dataset" onchange="onBossChange()">
                            <option value="brutallus" data-i18n="boss.brutallus">Brutallus</option>
                            <option value="felmyst" data-i18n="boss.felmyst">Felmyst</option>
                            <option value="eredar_twins" data-i18n="boss.eredar_twins">Eredar Twins</option>
                            <option value="muru" data-i18n="boss.muru">M'uru</option>
                        </select>
                    </div>
                    <div class="filter-item" id="phaseFilterContainer" style="display: none;">
                        <label for="phaseSelect">Phase:</label>
                        <select id="phaseSelect" onchange="loadData()">
                            <option value="1">Phase 1</option>
                            <option value="2">Phase 2</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="totalHealers">Total Healers:</label>
                        <select id="totalHealers" onchange="loadTopN()">
                            <option value="">Any</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="rotatingOnTank">Rotating on Tank:</label>
                        <select id="rotatingOnTank" onchange="loadTopN()">
                            <option value="">Any</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                </div>

                <!-- Buffs & Support Section -->
                <div class="filter-section">
                    <div class="filter-section-title">Buffs & Support</div>
                    <div class="filter-item">
                        <label for="shadowPriest">Shadow Priest:</label>
                        <select id="shadowPriest" onchange="loadTopN()">
                            <option value="">Any</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="innervates">Innervates:</label>
                        <select id="innervates" onchange="loadTopN()">
                            <option value="" selected>Any</option>
                            <option value="0">0</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>
                    </div>
                    <div style="margin-top: 20px;">
                        <div style="color: #eee; font-weight: 600; font-size: 0.9em; margin-bottom: 8px;">Region:</div>
                        <div class="region-checkboxes" style="margin-left: 10px;">
                            <label><input type="checkbox" id="regionUS" value="US" checked onchange="loadTopN()"> US</label>
                            <label><input type="checkbox" id="regionEU" value="EU" checked onchange="loadTopN()"> EU</label>
                            <label><input type="checkbox" id="regionCN" value="CN" checked onchange="loadTopN()"> CN</label>
                            <label><input type="checkbox" id="regionKR" value="KR" checked onchange="loadTopN()"> KR</label>
                        </div>
                    </div>
                </div>

                <!-- Healer Composition Section -->
                <div class="filter-section">
                    <div class="filter-section-title">Healer Composition</div>
                    <div class="healer-comp-grid">
                        <div class="filter-item">
                            <label for="nDruid">Druids:</label>
                            <select id="nDruid" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nPaladin">Paladins:</label>
                            <select id="nPaladin" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nHPriest">Holy Priests:</label>
                            <select id="nHPriest" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nDPriest">Disc Priests:</label>
                            <select id="nDPriest" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nShaman">Shamans:</label>
                            <select id="nShaman" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title" data-i18n="chart.hpsVsHaste">HPS vs Haste</div>
                    <button class="chart-collapse-btn" onclick="toggleChart('hasteChart', this)">Collapse</button>
                </div>
                <div class="chart-content" id="hasteChartContent">
                    <canvas id="hasteChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">Average HPS by Primary Rotation</div>
                    <button class="chart-collapse-btn" onclick="toggleChart('rotationChart', this)">Collapse</button>
                </div>
                <div class="chart-content" id="rotationChartContent">
                    <canvas id="rotationChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">HPS vs Duration</div>
                    <button class="chart-collapse-btn" onclick="toggleChart('hpsChart', this)">Expand</button>
                </div>
                <div class="chart-content collapsed" id="hpsChartContent">
                    <canvas id="hpsChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Data Dictionary Section -->
        <div class="data-dictionary">
            <div class="data-dictionary-header" onclick="toggleDataDictionary()">
                <div class="data-dictionary-title">Data Dictionary</div>
                <button class="collapse-btn" id="dataDictBtn">Expand</button>
            </div>
            <div class="data-dictionary-content" id="dataDictContent">
                <!-- Talents -->
                <div class="dict-category">
                    <div class="dict-category-title">Talents & Spec</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Deep Resto / Tree of Life</div>
                            <div class="dict-definition">Full Restoration spec with Tree of Life form. Provides better mana efficiency and rotational flexibility compared to Dreamstate and Nautre's Grace.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Dreamstate</div>
                            <div class="dict-definition">Hybrid spec investing in Balance for "Improved Faerie Fire", though called Dreamstate for historical reasons. In this spec, Druids sacrifice Tree of Life and Swiftmend.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Nature's Grace</div>
                            <div class="dict-definition">Balance talent that reduces next cast time by 0.5s after a spell crit, supporting a Regrowth-heavy playstyle with considerably high HPS but with significant mana constraints. In WarcraftLogs, Deep Resto and Nature's Grace are both categorized as Restoration. To identify Nature's Grace builds, we check if the Druid had the Nature's Grace buff at any point during the encounter.</div>
                        </div>
                    </div>
                </div>

                <!-- Playstyle & Rotation -->
                <div class="dict-category">
                    <div class="dict-category-title">Playstyle & Rotation</div>
                    <div class="dict-item" style="margin-bottom: 15px;">
                        <div class="dict-term">Rotation</div>
                        <div class="dict-definition">
                            <p style="margin-bottom: 10px;">A "rotation" is the sequence of spells that the Druid casts, either while maintaining Lifebloom on the tank(s) or not. For an introductory overview on rotations, I'd refer you to SixPacKyx's <a href="https://www.wowhead.com/tbc/guide/classes/druid/healer-rotation-cooldowns-abilities-pve" target="_blank" style="color: #667eea;">WowHead guide</a> under the "Rolling Lifebloom: Advanced Restoration Druid Healing Rotation" section, and additionally giansm's <a href="https://web.archive.org/web/20080913120521/http://elitistjerks.com/f31/t17783-druid_raiding_tree/#Healing_Strategies" target="_blank" style="color: #667eea;">Elitist Jerks guide</a> under the "Healing Strategies" section.</p>
                            <p style="margin-bottom: 10px;">To help discuss rotations more easily, I've created a standard notation for rotations: <strong style="color: #DE772A;">xLB yI zRG</strong></p>
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li><strong>x:</strong> The number of tanks you are rolling Lifebloom on during a rotation.</li>
                                <li><strong>y:</strong> The number of instant cast spells used during a rotation (Rejuv, Swiftmend, Lifebloom on non-tanks, etc.)</li>
                                <li><strong>z:</strong> The number of Regrowth casts used during the rotation.</li>
                            </ul>
                            <p style="margin-top: 15px; margin-bottom: 10px;">To illustrate, here are a few examples:</p>
                            <ul style="margin-left: 20px;">
                                <li><strong style="color: #DE772A;">1LB 1I 1RG</strong> - A typical unhasted 1 tank rotation. The Druid refreshes Lifebloom on the tank, uses an instant cast spell (perhaps refreshing Rejuv on the tank), and casts 1 Regrowth.</li>
                                <li><strong style="color: #DE772A;">2LB 2I 0RG</strong> - A typical unhasted 2 tank rotation. The Druid refreshes Lifebloom on two tanks and uses two instant cast spells, but does not cast any Regrowths.</li>
                                <li><strong style="color: #DE772A;">0LB 0I 5RG</strong> - The Druid does not cast Lifebloom on any tank, but instead casts Regrowth five times in a row.</li>
                            </ul>
                        </div>
                    </div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Rotating on Tank</div>
                            <div class="dict-definition">We programatically list all of the rotations the Druid did over the course of the encounter, and check if at least 70% (chosen arbitrarily) of the Druid's rotations on a fight include a Lifebloom on at least one of the tanks (see Report Analyzer tool for more details). If so, then Rotating on Tank is "Yes", otherwise "No".</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Primary Rotation</div>
                            <div class="dict-definition">The most frequently used rotation pattern during the encounter.</div>
                        </div>
                    </div>
                </div>

                <!-- Player Information -->
                <div class="dict-category">
                    <div class="dict-category-title">Player Information</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Name</div>
                            <div class="dict-definition">The character name of the Restoration Druid as it appears on WarcraftLogs.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Server</div>
                            <div class="dict-definition">The realm/server where the character is located.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Region</div>
                            <div class="dict-definition">Geographic region of the server: US (Americas), EU (Europe), CN (China), or KR (Korea).</div>
                        </div>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="dict-category">
                    <div class="dict-category-title">Performance Metrics</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">HPS</div>
                            <div class="dict-definition">Healing Per Second. Total effective healing done divided by fight duration. This is the primary performance metric used for ranking.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Duration</div>
                            <div class="dict-definition">Total length of the boss encounter from pull to kill, displayed in minutes and seconds (e.g., "4m 24s").</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Adjusted Rank</div>
                            <div class="dict-definition">The player's position within the current filtered dataset. Changes dynamically based on active filters.</div>
                        </div>
                    </div>
                </div>

                <!-- Character Stats -->
                <div class="dict-category">
                    <div class="dict-category-title">Character Stats</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Haste</div>
                            <div class="dict-definition">Spell Haste rating at the start of the encounter. Is sometimes unavailable in a report, represented by "-".</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Spirit</div>
                            <div class="dict-definition">Spirit stat at the start of the encounter. Is sometimes unavailable in a report, represented by "-".</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Intellect</div>
                            <div class="dict-definition">Intellect stat at the start of the encounter. Is sometimes unavailable in a report, represented by "-".</div>
                        </div>
                    </div>
                </div>

                <!-- Raid Composition -->
                <div class="dict-category">
                    <div class="dict-category-title">Raid Composition</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Total Healers</div>
                            <div class="dict-definition">Number of healers in the raid.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">nDruid / nPaladin / etc.</div>
                            <div class="dict-definition">Count of each healer class in the raid.</div>
                        </div>
                    </div>
                </div>

                <!-- Buffs & External Support -->
                <div class="dict-category">
                    <div class="dict-category-title">Buffs & External Support</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Shadow Priest (Vampiric Touch)</div>
                            <div class="dict-definition">Whether the Druid had a Shadow Priest providing Vampiric Touch mana regeneration at any point during the encounter.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Innervates</div>
                            <div class="dict-definition">Number of Innervates received during the encounter.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="table-container">
            <div class="table-header">
                <div class="table-title">
                    <span>Rankings</span>
                    <span class="filtered-count" id="filteredCount"></span>
                </div>
                <div class="table-controls">
                    <label for="topN">Show Top:</label>
                    <input type="number" id="topN" value="20" min="1" max="100">
                    <button onclick="loadTopN()">Update</button>
                    <button class="collapse-btn" id="collapseBtn" onclick="toggleTable()">Collapse</button>
                </div>
            </div>
            <div class="table-content" id="tableContent">
                <table id="dataTable">
                <thead>
                    <tr>
                        <th>Adjusted<br>Rank</th>
                        <th>Name</th>
                        <th>Server</th>
                        <th>Region</th>
                        <th>Duration</th>
                        <th>HPS</th>
                        <th data-i18n="table.haste">Haste</th>
                        <th>Spirit</th>
                        <th>Total<br>Healers</th>
                        <th>Innervates</th>
                        <th>Shadow<br>Priest</th>
                        <th>Rotating<br>on Tank</th>
                        <th>Primary<br>Rotation</th>
                        <th>Report<br>Link</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <tr>
                        <td colspan="14" class="loading">Loading data...</td>
                    </tr>
                </tbody>
            </table>
            </div>
        </div>
            </div>
        </div>

        <!-- Report Analyzer Tab -->
        <div id="reportTab" class="tab-content">
            <div class="container">
                <h1>Report Analyzer</h1>

                <div class="notice-banner">
                    <h3>Analyze Individual Reports</h3>
                    <p>Enter a WarcraftLogs report code (or full URL), the boss name, and the Restoration Druid's name to get a comprehensive performance analysis including rotation patterns, buff tracking, and HPS breakdown.</p>
                </div>

                <hr class="section-divider">

                <!-- Input Form -->
                <div class="controls" id="analyzerForm">
                    <div class="controls-title">Report Details</div>
                    <div class="controls-row" style="flex-wrap: wrap; gap: 15px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="reportCode">Report Code/URL:</label>
                            <input type="text" id="reportCode" placeholder="e.g., wX7H9RtYJ48P1cdW" style="width: 280px;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="bossName">Boss:</label>
                            <select id="bossName" style="width: 180px;">
                                <option value="Brutallus" data-i18n="boss.brutallus">Brutallus</option>
                                <option value="Felmyst" data-i18n="boss.felmyst">Felmyst</option>
                                <option value="Eredar Twins">Eredar Twins</option>
                                <option value="M'uru">M'uru</option>
                                <option value="Kil'jaeden">Kil'jaeden</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="playerName">Player Name:</label>
                            <input type="text" id="playerName" placeholder="e.g., Mercychann" style="width: 180px;">
                        </div>
                        <button onclick="analyzeReport()" id="analyzeBtn">Analyze</button>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="analyzerLoading" style="display: none; text-align: center; padding: 40px;">
                    <div style="color: #667eea; font-size: 1.2em; margin-bottom: 10px;">Analyzing report...</div>
                    <div style="color: #8b9dc3;">This may take 10-30 seconds depending on the report</div>
                    <div class="loading-spinner" style="margin-top: 20px;"></div>
                </div>

                <!-- Error Display -->
                <div id="analyzerError" style="display: none;" class="notice-banner" style="border-color: #ef4444;">
                    <h3 style="color: #ef4444;">Error</h3>
                    <p id="errorMessage" style="color: #fca5a5;"></p>
                </div>

                <!-- Results Container -->
                <div id="analyzerResults" style="display: none;">
                    <!-- Encounter Info -->
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Encounter Date</h3>
                            <div class="value" id="resultDate">-</div>
                        </div>
                        <div class="stat-card">
                            <h3>Duration</h3>
                            <div class="value" id="resultDuration">-</div>
                        </div>
                        <div class="stat-card">
                            <h3>Total Healers</h3>
                            <div class="value" id="resultHealers">-</div>
                        </div>
                    </div>

                    <!-- Player Performance -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Player Performance</div>
                            <a id="reportLink" href="#" target="_blank" style="padding: 8px 16px; background: #667eea; color: white; text-decoration: none; border-radius: 5px; font-weight: 600;">View on WarcraftLogs</a>
                        </div>
                        <div class="stats-grid" style="margin-bottom: 0;">
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Player</h3>
                                <div class="value" style="font-size: 1.5em;" id="resultPlayerName">-</div>
                                <div style="color: #8b9dc3; margin-top: 5px;" id="resultPlayerServer">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>HPS</h3>
                                <div class="value" style="color: #10b981;" id="resultHPS">-</div>
                                <div style="color: #8b9dc3; margin-top: 5px;" id="resultRank">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Stats</h3>
                                <div style="color: #fff; font-size: 1em;">
                                    <span id="resultIntellect">-</span> Int |
                                    <span id="resultSpirit">-</span> Spirit |
                                    <span id="resultHaste">-</span> Haste
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Buffs & Resources -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Buffs & Resources</div>
                        </div>
                        <div class="stats-grid" style="margin-bottom: 0;">
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Vampiric Touch</h3>
                                <div id="resultVT">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Innervate Count</h3>
                                <div class="value" id="resultInnervate">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Bloodlust/Heroism</h3>
                                <div id="resultBL">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Nature's Grace</h3>
                                <div id="resultNG">-</div>
                            </div>
                        </div>
                    </div>

                    <!-- Trinkets -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Trinkets</div>
                        </div>
                        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 200px;">
                                <div style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 5px;">Trinket 1</div>
                                <div style="color: #fff; font-weight: 600;" id="resultTrinket1">-</div>
                            </div>
                            <div style="flex: 1; min-width: 200px;">
                                <div style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 5px;">Trinket 2</div>
                                <div style="color: #fff; font-weight: 600;" id="resultTrinket2">-</div>
                            </div>
                        </div>
                    </div>

                    <!-- HoT Breakdown -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">HoT Breakdown</div>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th>Spell</th>
                                    <th>HPS</th>
                                    <th>% of Total</th>
                                    <th>Details</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong style="color: #10b981;">Lifebloom</strong></td>
                                    <td id="resultLBHPS">-</td>
                                    <td id="resultLBPercent">-</td>
                                    <td id="resultLBUptime">-</td>
                                </tr>
                                <tr>
                                    <td><strong style="color: #f472b6;">Rejuvenation</strong></td>
                                    <td id="resultRejuvHPS">-</td>
                                    <td id="resultRejuvPercent">-</td>
                                    <td>-</td>
                                </tr>
                                <tr>
                                    <td><strong style="color: #60a5fa;">Regrowth</strong></td>
                                    <td id="resultRGHPS">-</td>
                                    <td id="resultRGPercent">-</td>
                                    <td id="resultRGRanks">-</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Healer Composition -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Healer Composition</div>
                        </div>
                        <div id="healerCompList" style="display: flex; flex-wrap: wrap; gap: 20px;"></div>
                    </div>

                    <!-- Rotation Analysis -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Rotation Analysis</div>
                            <button class="collapse-btn" onclick="toggleRotationTable()">Collapse</button>
                        </div>
                        <div class="stats-grid" style="margin-bottom: 20px;">
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Total Rotations</h3>
                                <div class="value" id="resultRotationCount">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Tank Rotation %</h3>
                                <div class="value" id="resultTankRotation">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Rotating on Tank</h3>
                                <div id="resultRotatingOnTank">-</div>
                            </div>
                        </div>
                        <div id="rotationTableContent">
                            <h4 style="color: #8b9dc3; margin-bottom: 15px;">Top Rotation Patterns</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>Pattern</th>
                                        <th>Count</th>
                                        <th>Percentage</th>
                                    </tr>
                                </thead>
                                <tbody id="rotationPatternsBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Cast Sequence -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">
                                <span>Cast Sequence</span>
                                <span class="filtered-count" id="castCount"></span>
                            </div>
                            <button class="collapse-btn" id="castSequenceCollapseBtn" onclick="toggleCastSequence()">Collapse</button>
                        </div>
                        <div id="castSequenceContent" style="max-height: 500px; overflow-y: auto;">
                            <table>
                                <thead style="position: sticky; top: 0; background: #0f3460;">
                                    <tr>
                                        <th>Time</th>
                                        <th>Spell</th>
                                        <th>Target</th>
                                        <th>Active Tank</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody id="castSequenceBody"></tbody>
                            </table>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Community Theorycrafting Tab -->
        <div id="theorycraftingTab" class="tab-content">
            <div class="container">
                <h1>Community Theorycrafting</h1>

                <div class="notice-banner">
                    <h3>Notice</h3>
                    <p>This section is dedicated to analyses or "blog" style posts. I'll be writing some posts myself, but I'm looking for community members who are interested in contributing! You can write a post on any topic or analysis that you think would be interesting or helpful for the community. You'll be fully credited for the post and listed as a contributor in the About section.</p>
                    <p>I can help with the formatting of the post and visuals if needed, or we could even collab on an analysis. Anything goes! I'd love for members of the community to get engaged and help push the knowledge of the spec further. Please reach out if you're interested!</p>
                    <p class="signature">- Mercy</p>
                </div>

                <!-- Haste Breakpoints Guide -->
                <div class="theorycraft-section">
                    <div class="theorycraft-header" onclick="toggleTheorycraft('hasteBreakpoints', this)">
                        <h2 style="margin: 0; color: #bebeb1; font-size: 1.2em;">Rotation Theory & Haste Breakpoints</h2>
                        <button class="collapse-btn theorycraft-toggle">Expand</button>
                    </div>
                    <div class="theorycraft-content collapsed" id="hasteBreakpointsContent">
                        <br>
                        <p>As a Restoration Druid maintaining Lifebloom on a tank, your healing follows a <strong>rotation cycle</strong> - the sequence of spells you cast between Lifebloom refreshes. Since Lifebloom has a 7-second duration, you have a limited window to weave in additional heals before needing to refresh it.</p>
                        <p>This write-up provides a deep dive on rotations and haste breakpoints. The intent with this post is to explain what rotations <strong>are possible</strong> at different breakpoints. Which rotations are <strong>optimal</strong> in any given situation is outside the scope of this post.</p>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <h3>Rotation Mechanics</h3>

                        <br>

                        <p>For an introductory overview on rotations, I'd refer you to SixPacKyx's <a href="https://www.wowhead.com/tbc/guide/classes/druid/healer-rotation-cooldowns-abilities-pve" target="_blank" style="color: #667eea;">WowHead guide</a> under the "Rolling Lifebloom: Advanced Restoration Druid Healing Rotation" section, and additionally giansm's <a href="https://web.archive.org/web/20080913120521/http://elitistjerks.com/f31/t17783-druid_raiding_tree/#Healing_Strategies" target="_blank" style="color: #667eea;">Elitist Jerks guide</a> under the "Healing Strategies" section.</p>
                            
                        <p style="margin-bottom: 10px;">To help discuss rotations more easily, I've created a standard notation for rotations: <strong style="color: #DE772A;">xLB yI zRG</strong></p>
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li><strong>x:</strong> The number of tanks you are rolling Lifebloom on during a rotation.</li>
                            <li><strong>y:</strong> The number of instant cast spells used during a rotation (Rejuv, Swiftmend, Lifebloom on non-tanks, etc.)</li>
                            <li><strong>z:</strong> The number of Regrowth casts used during the rotation.</li>
                        </ul>
                        <p style="margin-top: 15px; margin-bottom: 10px;">To illustrate, here are a few examples:</p>
                        <ul style="margin-left: 20px;">
                            <li><strong style="color: #DE772A;">1LB 1I 1RG</strong> - A typical unhasted 1 tank rotation. The Druid refreshes Lifebloom on the tank, uses an instant cast spell (perhaps refreshing Rejuv on the tank), and casts 1 Regrowth.</li>
                            <li><strong style="color: #DE772A;">2LB 2I 0RG</strong> - A typical unhasted 2 tank rotation. The Druid refreshes Lifebloom on two tanks and uses two instant cast spells, but does not cast any Regrowths.</li>
                            <li><strong style="color: #DE772A;">0LB 0I 5RG</strong> - The Druid does not cast Lifebloom on any tank, but instead casts Regrowth five times in a row.</li>
                        </ul>

                        <p style="margin-bottom: 10px;">In the following sections, I'll only be tabulating single-tank rotations (1LB yI zRG), but equivalent 2-tank and 3-tank rotations can be done by exchanging an instant cast with a tank lifebloom,</p>
                        <ul style="margin-left: 20px;">
                            <li><strong style="color: #DE772A;">[1LB 3I 0RG]</strong> = <strong style="color: #DE772A;">[2LB 2I 0RG]</strong> = <strong style="color: #DE772A;">[3LB 1I 0RG]</strong></li>
                        </ul>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <h2>0 Spell Haste Rating</h2>
                        <br>
                        <p>For most of the expansion (all of t4, t5, and some of t6) you'll have no haste. These rotations will be your bread-and-butter for most of your time in TBC, so get familiar with them!</p>

                        <table style="margin: 1em 0; max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Rotation</th>
                                    <th>Instants</th>
                                    <th>Regrowths</th>
                                    <th>Time Used</th>
                                    <th>Buffer</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>[1LB 1I 1RG]</strong></td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>5.0s</td>
                                    <td>2.0s</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 0I 2RG]</strong></td>
                                    <td>0</td>
                                    <td>2</td>
                                    <td>5.5s</td>
                                    <td>1.5s</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 3I 0RG]</strong></td>
                                    <td>3</td>
                                    <td>0</td>
                                    <td>6.0s</td>
                                    <td>1.0s</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 2I 1RG]</strong></td>
                                    <td>2</td>
                                    <td>1</td>
                                    <td>6.5s</td>
                                    <td>0.5s</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 1I 2RG]</strong></td>
                                    <td>1</td>
                                    <td>2</td>
                                    <td>7.0s</td>
                                    <td>0.0s</td>
                                </tr>
                            </tbody>
                        </table>

                        <br>
                        <strong>However...</strong> Experienced players will raise an eyebrow at the above list. Why? Because we're missing an important part of the conversation...
                        <br><br>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <h2>Latency</h2>
                        <br>
                        <p><strong>In theory</strong>, the above 5 rotations are possible at 0 haste. <strong>In practice</strong>, latency (ping) limits your options. When you cast a spell, you must wait for the server to register it before your next cast. This creates an <strong>effective "Server GCD"</strong>:</p>
                        
                        <h5 style="margin-top: 1.5em;">Effective GCD by Ping</h5>
                        <table style="margin: 1em 0; max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Normal GCD</th>
                                    <th>Ping</th>
                                    <th>Effective GCD</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>1.50s</td>
                                    <td>0ms</td>
                                    <td>1.50s</td>
                                </tr>
                                <tr>
                                    <td>1.50s</td>
                                    <td>50ms</td>
                                    <td>~1.55s</td>
                                </tr>
                                <tr>
                                    <td>1.50s</td>
                                    <td>100ms</td>
                                    <td>~1.60s</td>
                                </tr>
                                <tr>
                                    <td>1.50s</td>
                                    <td>150ms</td>
                                    <td>~1.65s</td>
                                </tr>
                            </tbody>
                        </table>

                        <h5 style="margin-top: 1.5em;">Rotation Viability by Ping</h5>
                        <table style="margin: 1em 0; max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Rotation</th>
                                    <th>0ms</th>
                                    <th>50ms</th>
                                    <th>100ms</th>
                                    <th>150ms</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>[1LB 1I 1RG]</strong></td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 0I 2RG]</strong></td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 3I 0RG]</strong></td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 2I 1RG]</strong></td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✓</td>
                                    <td>✗</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 1I 2RG]</strong></td>
                                    <td>✓</td>
                                    <td>✗</td>
                                    <td>✗</td>
                                    <td>✗</td>
                                </tr>
                            </tbody>
                        </table>

                        Does that mean you might be stuck with the same three rotations for most of the expansion? Yep! Get used to it.
                        <br><br>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <h2>Hyjal / BT / Zul'Aman Haste Breakpoints</h2>

                        <h4>Haste Formulas</h4>
                        <pre style="background: #0a0d0a; padding: 1em; border-radius: 5px; overflow-x: auto; color: #90ee90; max-width: 600px;">GCD = 1.5 / (1 + Haste Rating / 1577)
Regrowth Cast Time = 2.0 / (1 + Haste Rating / 1577)</pre>
                        <br>

                        <p>As you begin to acquire haste from gear, new rotations become possible. With one or two items you'll quickly be able to cast <strong style="color: #DE772A;">[1LB 1I 2RG]</strong>.</p>
                        <p>With Hyjal / BT you can expect to collect at most around 230 Haste (good luck getting those rings and cloak 🙂). With just a few items you'll unlock the often mentioned "5-GCD" rotation, <strong style="color: #DE772A;">[1LB 4I 0RG]</strong>, which can be a fun rotation to do on Illidari Council.</p>
                        <p>Less often mentioned, you'll unlock <strong style="color: #DE772A;">[1LB 0I 3RG]</strong> at about the same haste level. Though Hjal/BT offers a lot of haste options, there's not much point going beyond the 113 Haste breakpoint, as the next breakpoint isn't realistically reachable until Zul'Aman releases.</p>
                        <p>With the release of Zul'Aman, you can get up to about 300 Haste rating, allowing you to comfortably cast <strong style="color: #DE772A;">[1LB 3I 1RG]</strong>, though you'd be very lucky to collect that much Haste gear before the release of Sunwell!</p>

                        <h5 style="margin-top: 1.5em;">Minimum Haste Required by Latency</h5>
                        <table style="margin: 1em 0; max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Rotation</th>
                                    <th>0ms</th>
                                    <th>50ms</th>
                                    <th>100ms</th>
                                    <th>150ms</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>[1LB 1I 2RG]</strong></td>
                                    <td>0</td>
                                    <td>11</td>
                                    <td>23</td>
                                    <td>35</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 4I 0RG]</strong></td>
                                    <td>113</td>
                                    <td>125</td>
                                    <td>137</td>
                                    <td>150</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 0I 3RG]</strong></td>
                                    <td>113</td>
                                    <td>125</td>
                                    <td>137</td>
                                    <td>150</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 3I 1RG]</strong></td>
                                    <td>225</td>
                                    <td>238</td>
                                    <td>251</td>
                                    <td>265</td>
                                </tr>
                            </tbody>
                        </table>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <br>
                        <h2>Sunwell Plateau Haste Breakpoints</h2>
                        <br>
                        <p>With Sunwell gear, significantly higher haste values become achievable, unlocking additional rotations. From gear alone you can expect to get around 400 Haste rating, giving you access to <strong style="color: #DE772A;">[1LB 2I 2RG]</strong>.</p>
                        <p>However, with Sunwell we also get access to the Quick Lionseye gem (+10 Spell Haste), allowing you to reach a little over 500 Haste and access to <strong style="color: #DE772A;">[1LB 5I 0RG]</strong> and <strong style="color: #DE772A;">[1LB 1I 3RG]</strong>.</p>

                        <h5 style="margin-top: 1.5em;">Minimum Haste Required by Latency</h5>
                        <table style="margin: 1em 0; max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Rotation</th>
                                    <th>0ms</th>
                                    <th>50ms</th>
                                    <th>100ms</th>
                                    <th>150ms</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>[1LB 2I 2RG]</strong></td>
                                    <td>338</td>
                                    <td>352</td>
                                    <td>366</td>
                                    <td>380</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 5I 0RG]</strong></td>
                                    <td>451</td>
                                    <td>465</td>
                                    <td>480</td>
                                    <td>495</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 1I 3RG]</strong></td>
                                    <td>451</td>
                                    <td>465</td>
                                    <td>480</td>
                                    <td>495</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 4I 1RG]</strong></td>
                                    <td>563</td>
                                    <td>579</td>
                                    <td>594</td>
                                    <td>610</td>
                                </tr>
                            </tbody>
                        </table>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <br>
                        <h2>To go... Even further beyond...</h2>
                        <br>
                        <p>With <strong>Bloodlust/Heroism</strong> active (30% haste buff), you'll have access to rotations that would otherwise not be possible from gear alone. Eventually, the GCD becomes capped at <strong>1.0s</strong></p>
                        <p>Below are a set of minimum haste ratings needed to do these set of rotations while under Bloodlust. The last example, <strong style="color: #DE772A;">[1LB 0I 6RG]</strong>, is not possible even with max Haste and Bloodlust.</p>

                        <h5 style="margin-top: 1.5em;">Minimum Haste Required by Latency (with Bloodlust)</h5>
                        <table style="margin: 1em 0; max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Rotation</th>
                                    <th>0ms</th>
                                    <th>50ms</th>
                                    <th>100ms</th>
                                    <th>150ms</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>[1LB 4I 1RG]</strong></td>
                                    <td>70</td>
                                    <td>82</td>
                                    <td>93</td>
                                    <td>106</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 3I 2RG]</strong></td>
                                    <td>156</td>
                                    <td>169</td>
                                    <td>181</td>
                                    <td>194</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 6I 0RG]</strong></td>
                                    <td>243</td>
                                    <td>339</td>
                                    <td>445</td>
                                    <td>565</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 2I 3RG]</strong></td>
                                    <td>243</td>
                                    <td>265</td>
                                    <td>289</td>
                                    <td>314</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 1I 4RG]</strong></td>
                                    <td>364</td>
                                    <td>383</td>
                                    <td>404</td>
                                    <td>424</td>
                                </tr>
                                <tr>
                                    <td><strong>[1LB 0I 5RG]</strong></td>
                                    <td>445</td>
                                    <td>462</td>
                                    <td>479</td>
                                    <td>497</td>
                                </tr>
                                <tr style="color: #888;">
                                    <td>[1LB 0I 6RG]</td>
                                    <td>849</td>
                                    <td>869</td>
                                    <td>890</td>
                                    <td>911</td>
                                </tr>
                            </tbody>
                        </table>

                        <br><br>
                        <h2>Rotation Unlock by Haste</h2>
                        <br>
                        <p>The following chart visualizes when each rotation becomes available as you acquire more haste:</p>
                        <div style="max-width: 700px; margin: 1em 0;">
                            <div style="margin-bottom: 1em;">
                                <label for="latencySlider" style="display: inline-block; margin-right: 1em;">Latency: <strong id="latencyValue">0ms</strong></label>
                                <input type="range" id="latencySlider" min="0" max="300" step="10" value="0" style="width: 200px; vertical-align: middle;">
                            </div>
                            <div style="height: 450px;">
                                <canvas id="hasteBreakpointChart"></canvas>
                            </div>
                        </div>

                        <hr style="border-color: #3a3d3a; margin: 2em 0;">

                        <h2>Wrapping Up</h2>
                        <br>

                        <p>Hopefully this gives you some impression about the amount of complexity in Resto Druid. But don't worry, it gets worse! Here's a couple points to consider: 
                            
                        <p>First, just because you can reach the breakpoint for a new rotation, it doesn't mean that you should. This write-up <strong>only</strong> covers what is possible, not what is good. What is possible and what is <strong>optimal</strong> are two completely different questions. I say that because a very important constraint has been left out of this conversation entirely: <strong>mana</strong>. Just because you've unlocked a new Regrowth-heavy rotation doesn't mean that you have the mana to do it. The complexity of Resto Druid does not come from knowing what rotations there are, but <strong>which one to do</strong> given the specifics of the encounter and your situation.</p>
                        
                        <p>Second, layered on top of that, the same kind of rotation can actually serve different purposes. As a simple example, consider <strong style="color: #DE772A;">[1LB 1I 1RG]</strong>. You put Lifebloom on the tank, but what do you do with your instant and Regrowth cast? Should they also go onto the tank, or elsewhere?</p>
                        <p>You'll meet some purists in the community who will tell you that all GCDs go on the tank. "That's your job." You'll meet other healers that just neglect the tank and put their GCDs onto the raid instead. What will you do?</p>
                        <p>Here's my opinion: what you choose to do with your GCDs is up to you, every seven seconds. No other healer in TBC has the level of flexibility combined with direct throughput that a Resto Druid has, and that becomes a superpower once you learn how to use it. Thanks for reading!</p>

                        <p class="signature">- Mercy</p>

                    </div>
                </div>

            </div>
        </div>

        <!-- About Tab -->
        <div id="aboutTab" class="tab-content">
            <div class="container">
                <h1>About</h1>

                <div class="about-section">
                    <h2>About Lifebloom</h2>
                    <p>Lifebloom is an application that collects and structures TBC Resto Druid data from WarcraftLogs in order to help facilitate retrospective data analyses by and for the community. This app is still in development in preparation for the next iteration of TBC Classic.</p>
                </div>

                <div class="about-section justified">
                    <h2>Motivation</h2>
                    <p>The Burning Crusade is almost 20 years old! 🎉 </p>
                        
                    <p>Despite so much time passing, I don't believe our collective understanding of Resto Druid has progressed significantly since 2007 - and not because the spec has been solved. With TBC Classic, I had hoped that the community would build upon existing knowledge from 2007 and the private server era, but instead what I observed was largely "re-discovery" and recycled guides, and very little theorycrafting or knowledge sharing.</p>
                    <p>To illustrate this, consider the following fundamental questions that I believe remain unanswered:</p>
                    <ul>
                        <li>For a given encounter, is there an optimal spell haste breakpoint?</li>
                        <li>For a given encounter, is there an optimal healing rotation?</li>
                    </ul>
                    <p>These questions appear straightforward, yet after 20 years neither has a definitive answer. Here's my hot take: traditional theorycrafting alone will never solve them.</p>
                    <p>The reason is multifaceted.</p>
                    <p>First, healer theorycrafting is inherently difficult. Raid encounters are complex environments with numerous confounding variables: healer count and composition, fight duration, access to Shadow Priest, etc. The optimal rotation for a 3-minute encounter may differ significantly from a 6-minute encounter due to mana constraints alone.</p>
                    <p>Second, the community is still split on whether HPS is a valid performance metric because of the confounding effects mentioned above. This has left us in a bit of a theorycrafting “quagmire” - without an objective measure of performance, players instead rely on intuition and subjective arguments about what is good or not. Intuition and experience can get you very far, but different players have different intuitions about what is "best". Layered on top of this is an uncomfortable dogma surrounding the topic of HPS, and just mentioning the word gets you harassed and dogpiled on. I think the community is wrong about HPS.</p>
                    <p>By analyzing large datasets while controlling for confounding variables we can isolate factors that you do have control over - rotation, playstyle, gearing choices, haste breakpoints, etc. across different encounters and conditions. I don't believe these fundamental questions are unanswerable, but we need a new approach. That is the motivation for this tool: combining traditional theorycrafting with data-driven analyses to address fundamental questions and to advance our understanding of the spec.</p>
                </div>

                <div class="about-section author-section justified">
                    <img src="/static/icons/avatar.png" alt="Mercy" class="author-avatar">
                    <div class="author-content">
                        <h2>About the Author</h2>
                        <p>Welcome readers! My name is Mercy (IGN Mercychan) and I've been playing TBC Resto Druid religiously since c. 2017 from the private server era and through TBC Classic. In my opinion TBC was when the class design for Resto Druid was at its best. In my professional life I LARP as a Data Scientist, and I'm hoping to bring together my experience in data science and my passion for this spec in order to help the community push our knowledge of TBC Resto Druid further.</p>
                        <p>If you want to support this project, the best way that you can do that is by using the tool and discussing your insights with the community. The more people become aware of and use this tool for their own analyses, the more we can learn together. If you found the app useful, consider giving the repo a star!</p>
                        <p>If you want to report bugs, request additions to the tool or dataset, or even collab on an analysis, the best way to contact me is via Discord. I'm not always in the community servers but my DMs are open! Feel free to reach out.</p>

                        <div class="contact-links">
                            <a href="https://github.com/msdec321/Lifebloom" target="_blank" class="contact-link">GitHub Repo</a>
                            <a href="https://classic.warcraftlogs.com/character/us/benediction/mercychann?zone=1013&partition=6&metric=hps" target="_blank" class="contact-link">WarcraftLogs</a>
                            <a href="https://www.twitch.tv/mercylolk" target="_blank" class="contact-link">Twitch</a>
                            <span class="contact-link discord">Discord: Mercy9226</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Language switching
        let currentLanguage = localStorage.getItem('language') || 'en';

        // Translations object
        const translations = {
            en: {
                'notice.title': 'Notice',
                'notice.welcome': 'Welcome to <span style="color: #39c07f; font-weight: 600;">Lifebloom</span>! This is an application that collects and structures TBC Resto Druid data from WarcraftLogs in order to help facilitate retrospective data analyses by and for the community. This app is still in development in preparation for the next iteration of TBC Classic.',
                'notice.moreInfo': 'For more information about the tool and how to contact the author, please check out the "About" tab. Thanks!',
                'icons.deepResto': 'Deep Resto',
                'icons.dreamstate': 'Dreamstate',
                'icons.naturesGrace': "Nature's Grace",
                'boss.brutallus': 'Brutallus',
                'boss.felmyst': 'Felmyst',
                'boss.eredar_twins': 'Eredar Twins',
                'boss.muru': "M'uru",
                'chart.haste': 'Haste',
                'chart.hpsVsHaste': 'HPS vs Haste',
                'chart.avgHpsByHasteBin': 'Avg HPS by Haste Bin',
                'table.haste': 'Haste'
            },
            zh: {
                'notice.title': '公告',
                'notice.welcome': '欢迎来到 <span style="color: #39c07f; font-weight: 600;">Lifebloom</span>！这是一款从 WarcraftLogs 收集并整理《燃烧的远征》恢复德鲁伊数据的应用程序，旨在帮助社区进行回顾性数据分析。本应用仍在开发中，为《燃烧的远征》怀旧服的下一阶段做准备。',
                'notice.moreInfo': '如需了解更多关于本工具的信息或联系作者，请查看"关于"选项卡。感谢！',
                'icons.deepResto': '生命之树',
                'icons.dreamstate': '梦境',
                'icons.naturesGrace': '自然之赐',
                'boss.brutallus': '布鲁塔卢斯',
                'boss.felmyst': '菲米丝',
                'boss.eredar_twins': '艾瑞达双子',
                'boss.muru': "穆鲁",
                'chart.haste': '急速',
                'chart.hpsVsHaste': 'HPS vs 急速',
                'chart.avgHpsByHasteBin': 'Avg HPS by 急速 Bin',
                'table.haste': '急速'
            }
        };

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('language', lang);

            // Update button states
            document.getElementById('langEN').classList.toggle('active', lang === 'en');
            document.getElementById('langZH').classList.toggle('active', lang === 'zh');

            // Apply translations
            applyTranslations(lang);

            // Refresh charts if they exist
            if (typeof updateHasteChart === 'function') {
                updateHasteChart();
            }
            if (typeof updateChart === 'function') {
                updateChart();
            }
            if (typeof updateRotationChart === 'function') {
                updateRotationChart();
            }
        }

        function applyTranslations(lang) {
            const langData = translations[lang];
            if (!langData) return;

            // Find all elements with data-i18n attribute and translate them
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (langData[key]) {
                    element.innerHTML = langData[key];
                }
            });

            console.log('Language set to:', lang);
        }

        // Initialize language on page load
        document.addEventListener('DOMContentLoaded', function() {
            setLanguage(currentLanguage);
        });

        // Tab switching
        function switchTab(tabName, updateHash = true) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active from all sidebar tabs
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            if (tabName === 'analysis') {
                document.getElementById('analysisTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(1)').classList.add('active');
                if (updateHash) window.location.hash = 'analysis';
            } else if (tabName === 'report') {
                document.getElementById('reportTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(2)').classList.add('active');
                if (updateHash) window.location.hash = 'report-analyzer';
            } else if (tabName === 'theorycrafting') {
                document.getElementById('theorycraftingTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(3)').classList.add('active');
                if (updateHash) window.location.hash = 'theorycrafting';
            } else if (tabName === 'about') {
                document.getElementById('aboutTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(4)').classList.add('active');
                if (updateHash) window.location.hash = 'about';
            }
        }

        // Handle URL hash on page load and hash change
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (hash === 'report-analyzer' || hash === 'report') {
                switchTab('report', false);
            } else if (hash === 'theorycrafting') {
                switchTab('theorycrafting', false);
            } else if (hash === 'about') {
                switchTab('about', false);
            } else {
                switchTab('analysis', false);
            }
        }

        // Listen for hash changes (back/forward browser buttons)
        window.addEventListener('hashchange', handleHashChange);

        // Chart instances
        let hpsChart = null;
        let hasteChart = null;
        let rotationChart = null;

        // Parse duration string (e.g., "4m 24s") to seconds
        function parseDurationToSeconds(duration) {
            if (!duration) return 0;
            let seconds = 0;
            const minuteMatch = duration.match(/(\d+)m/);
            const secondMatch = duration.match(/(\d+)s/);
            if (minuteMatch) seconds += parseInt(minuteMatch[1]) * 60;
            if (secondMatch) seconds += parseInt(secondMatch[1]);
            return seconds;
        }

        // Helper function to get selected regions
        function getSelectedRegions() {
            const regions = [];
            if (document.getElementById('regionUS').checked) regions.push('US');
            if (document.getElementById('regionEU').checked) regions.push('EU');
            if (document.getElementById('regionCN').checked) regions.push('CN');
            if (document.getElementById('regionKR').checked) regions.push('KR');
            return regions.join(',');
        }

        // Load and update chart with all filtered data
        async function updateChart() {
            const dataset = getDatasetName();
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with all filters but request all data (use high limit)
            let url = `/api/top/10000?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) {
                url += `&totalHealers=${totalHealers}`;
            }
            if (shadowPriest) {
                url += `&vampiricTouch=${shadowPriest}`;
            }
            if (innervates) {
                url += `&innervates=${innervates}`;
            }
            if (rotatingOnTank) {
                url += `&rotatingOnTank=${rotatingOnTank}`;
            }
            if (nDruid) {
                url += `&nDruid=${nDruid}`;
            }
            if (nPaladin) {
                url += `&nPaladin=${nPaladin}`;
            }
            if (nHPriest) {
                url += `&nHPriest=${nHPriest}`;
            }
            if (nDPriest) {
                url += `&nDPriest=${nDPriest}`;
            }
            if (nShaman) {
                url += `&nShaman=${nShaman}`;
            }
            if (regions) {
                url += `&regions=${regions}`;
            }

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;

                const ctx = document.getElementById('hpsChart').getContext('2d');

                // Parse data for chart
                const chartData = data.map(row => ({
                    x: parseDurationToSeconds(row.Duration),
                    y: row.HPS,
                    name: row.Name
                }));

                // Calculate min/max for y-axis
                const hpsValues = chartData.map(d => d.y);
                const minHPS = Math.min(...hpsValues);
                const yAxisMin = Math.max(0, minHPS - 100); // Don't go below 0

                // Destroy existing chart if it exists
                if (hpsChart) {
                    hpsChart.destroy();
                }

                // Create new chart
                hpsChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'HPS vs Duration',
                        data: chartData,
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = chartData[context.dataIndex];
                                    return `${point.name}: ${point.y.toFixed(2)} HPS at ${point.x}s`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Duration (seconds)',
                                color: '#8b9dc3',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#8b9dc3'
                            },
                            grid: {
                                color: 'rgba(139, 157, 195, 0.1)'
                            }
                        },
                        y: {
                            min: yAxisMin,
                            title: {
                                display: true,
                                text: 'HPS',
                                color: '#8b9dc3',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#8b9dc3',
                                callback: function(value, index, ticks) {
                                    // Hide the minimum tick value
                                    if (index === 0) {
                                        return '';
                                    }
                                    return value;
                                }
                            },
                            grid: {
                                color: 'rgba(139, 157, 195, 0.1)'
                            }
                        }
                    }
                }
                });
            } catch (error) {
                console.error('Error loading chart data:', error);
            }
        }

        // Load and update Haste chart with all filtered data
        async function updateHasteChart() {
            const dataset = getDatasetName();
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with all filters but request all data (use high limit)
            let url = `/api/top/10000?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) {
                url += `&totalHealers=${totalHealers}`;
            }
            if (shadowPriest) {
                url += `&vampiricTouch=${shadowPriest}`;
            }
            if (innervates) {
                url += `&innervates=${innervates}`;
            }
            if (rotatingOnTank) {
                url += `&rotatingOnTank=${rotatingOnTank}`;
            }
            if (nDruid) {
                url += `&nDruid=${nDruid}`;
            }
            if (nPaladin) {
                url += `&nPaladin=${nPaladin}`;
            }
            if (nHPriest) {
                url += `&nHPriest=${nHPriest}`;
            }
            if (nDPriest) {
                url += `&nDPriest=${nDPriest}`;
            }
            if (nShaman) {
                url += `&nShaman=${nShaman}`;
            }
            if (regions) {
                url += `&regions=${regions}`;
            }

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;

                const ctx = document.getElementById('hasteChart').getContext('2d');

                // Parse data for chart (filter out records with HasteGear = 0)
                const chartData = data
                    .filter(row => row.HasteGear > 0)
                    .map(row => ({
                        x: row.HasteGear,
                        y: row.HPS,
                        name: row.Name
                    }));

                // Calculate binned averages (bins of 50, starting from 100 for best, 0 for all)
                const binSize = 50;
                const binStart = dataSource === 'all' ? 0 : 100;
                const bins = {};

                chartData.forEach(point => {
                    if (point.x >= binStart) {
                        const binIndex = Math.floor((point.x - binStart) / binSize);
                        const binLabel = binStart + binIndex * binSize;
                        if (!bins[binLabel]) {
                            bins[binLabel] = { sum: 0, count: 0, values: [] };
                        }
                        bins[binLabel].sum += point.y;
                        bins[binLabel].count += 1;
                        bins[binLabel].values.push(point.y);
                    }
                });

                // Create sorted bin labels and calculate averages with error bars
                const binLabels = Object.keys(bins).map(Number).sort((a, b) => a - b);
                const binAverages = binLabels.map(label => {
                    const bin = bins[label];
                    const mean = bin.sum / bin.count;

                    // Calculate standard deviation
                    let stdDev = 0;
                    if (bin.count > 1) {
                        const squaredDiffs = bin.values.map(v => Math.pow(v - mean, 2));
                        const variance = squaredDiffs.reduce((a, b) => a + b, 0) / (bin.count - 1);
                        stdDev = Math.sqrt(variance);
                    }

                    // Error = std_dev / sqrt(n) (Standard Error of the Mean)
                    const error = stdDev / Math.sqrt(bin.count);

                    return {
                        x: label + binSize / 2,  // Center of bin
                        y: mean,
                        count: bin.count,
                        binRange: `${label}-${label + binSize - 1}`,
                        error: error,
                        stdDev: stdDev
                    };
                });

                // Calculate min for y-axis
                const hpsValues = chartData.map(d => d.y);
                const minHPS = Math.min(...hpsValues);
                const yAxisMin = Math.max(0, minHPS - 100);

                // Destroy existing chart if it exists
                if (hasteChart) {
                    hasteChart.destroy();
                }

                // Custom plugin for error bars
                const errorBarPlugin = {
                    id: 'errorBars',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const barDataset = chart.data.datasets.find(ds => ds.label === translations[currentLanguage]['chart.avgHpsByHasteBin']);
                        if (!barDataset) return;

                        const meta = chart.getDatasetMeta(chart.data.datasets.indexOf(barDataset));

                        ctx.save();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.lineWidth = 2;

                        meta.data.forEach((bar, index) => {
                            const dataPoint = binAverages[index];
                            if (dataPoint && dataPoint.error > 0) {
                                const x = bar.x;
                                const yScale = chart.scales.y;
                                const yTop = yScale.getPixelForValue(dataPoint.y + dataPoint.error);
                                const yBottom = yScale.getPixelForValue(dataPoint.y - dataPoint.error);
                                const capWidth = 6;

                                // Vertical line
                                ctx.beginPath();
                                ctx.moveTo(x, yTop);
                                ctx.lineTo(x, yBottom);
                                ctx.stroke();

                                // Top cap
                                ctx.beginPath();
                                ctx.moveTo(x - capWidth, yTop);
                                ctx.lineTo(x + capWidth, yTop);
                                ctx.stroke();

                                // Bottom cap
                                ctx.beginPath();
                                ctx.moveTo(x - capWidth, yBottom);
                                ctx.lineTo(x + capWidth, yBottom);
                                ctx.stroke();
                            }
                        });

                        ctx.restore();
                    }
                };

                // Create new chart
                hasteChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: translations[currentLanguage]['chart.avgHpsByHasteBin'],
                                type: 'bar',
                                data: binAverages,
                                backgroundColor: 'rgba(255, 159, 64, 0.4)',
                                borderColor: 'rgba(255, 159, 64, 1)',
                                borderWidth: 1,
                                barThickness: 20,
                                order: 2
                            },
                            {
                                label: translations[currentLanguage]['chart.hpsVsHaste'],
                                type: 'scatter',
                                data: chartData,
                                backgroundColor: 'rgba(102, 126, 234, 0.6)',
                                borderColor: 'rgba(102, 126, 234, 1)',
                                borderWidth: 1,
                                pointRadius: 5,
                                pointHoverRadius: 7,
                                order: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#8b9dc3'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const hasteLabel = translations[currentLanguage]['chart.haste'];
                                        if (context.dataset.label === translations[currentLanguage]['chart.hpsVsHaste']) {
                                            const point = chartData[context.dataIndex];
                                            return `${point.name}: ${point.y.toFixed(2)} HPS at ${point.x} ${hasteLabel}`;
                                        } else {
                                            const bin = binAverages[context.dataIndex];
                                            return `${hasteLabel} ${bin.binRange}: Avg ${bin.y.toFixed(2)} ± ${bin.error.toFixed(2)} HPS (n=${bin.count})`;
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: translations[currentLanguage]['chart.haste'],
                                    color: '#8b9dc3',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    color: '#8b9dc3'
                                },
                                grid: {
                                    color: 'rgba(139, 157, 195, 0.1)'
                                }
                            },
                            y: {
                                min: yAxisMin,
                                title: {
                                    display: true,
                                    text: 'HPS',
                                    color: '#8b9dc3',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    color: '#8b9dc3',
                                    callback: function(value, index, ticks) {
                                        // Hide the minimum tick value
                                        if (index === 0) {
                                            return '';
                                        }
                                        return value;
                                    }
                                },
                                grid: {
                                    color: 'rgba(139, 157, 195, 0.1)'
                                }
                            }
                        }
                    },
                    plugins: [errorBarPlugin]
                });
            } catch (error) {
                console.error('Error loading haste chart data:', error);
            }
        }

        // Load and update Rotation chart with average HPS by primary rotation
        async function updateRotationChart() {
            const dataset = getDatasetName();
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with all filters
            let url = `/api/top/10000?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) url += `&totalHealers=${totalHealers}`;
            if (shadowPriest) url += `&vampiricTouch=${shadowPriest}`;
            if (innervates) url += `&innervates=${innervates}`;
            if (rotatingOnTank) url += `&rotatingOnTank=${rotatingOnTank}`;
            if (nDruid) url += `&nDruid=${nDruid}`;
            if (nPaladin) url += `&nPaladin=${nPaladin}`;
            if (nHPriest) url += `&nHPriest=${nHPriest}`;
            if (nDPriest) url += `&nDPriest=${nDPriest}`;
            if (nShaman) url += `&nShaman=${nShaman}`;
            if (regions) url += `&regions=${regions}`;

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;

                const ctx = document.getElementById('rotationChart').getContext('2d');

                // Group by Rotation1 and calculate averages
                const rotationStats = {};
                data.forEach(row => {
                    const rotation = row.Rotation1;
                    if (rotation && rotation.trim()) {
                        if (!rotationStats[rotation]) {
                            rotationStats[rotation] = { sum: 0, count: 0, values: [] };
                        }
                        rotationStats[rotation].sum += row.HPS;
                        rotationStats[rotation].count += 1;
                        rotationStats[rotation].values.push(row.HPS);
                    }
                });

                // Calculate averages and sort by average HPS descending
                const rotationData = Object.entries(rotationStats)
                    .filter(([_, stats]) => stats.count >= 5)  // Min 5 samples
                    .map(([rotation, stats]) => {
                        const mean = stats.sum / stats.count;
                        let stdDev = 0;
                        if (stats.count > 1) {
                            const squaredDiffs = stats.values.map(v => Math.pow(v - mean, 2));
                            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / (stats.count - 1);
                            stdDev = Math.sqrt(variance);
                        }
                        const error = stdDev / Math.sqrt(stats.count);
                        return {
                            rotation,
                            avg: mean,
                            count: stats.count,
                            error,
                            stdDev
                        };
                    })
                    .sort((a, b) => b.avg - a.avg);

                // Calculate min and max for x-axis
                const minAvgHPS = Math.min(...rotationData.map(d => d.avg));
                const maxAvgHPS = Math.max(...rotationData.map(d => d.avg));
                const xAxisMin = Math.max(0, minAvgHPS - 50);
                const xAxisMax = maxAvgHPS + 50;

                // Destroy existing chart if it exists
                if (rotationChart) {
                    rotationChart.destroy();
                }

                // Custom plugin for error bars on rotation chart
                const rotationErrorBarPlugin = {
                    id: 'rotationErrorBars',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);

                        ctx.save();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.lineWidth = 2;

                        meta.data.forEach((bar, index) => {
                            const dataPoint = rotationData[index];
                            if (dataPoint && dataPoint.error > 0) {
                                const y = bar.y;
                                const xScale = chart.scales.x;
                                const xRight = xScale.getPixelForValue(dataPoint.avg + dataPoint.error);
                                const xLeft = xScale.getPixelForValue(dataPoint.avg - dataPoint.error);
                                const capWidth = 4;

                                // Horizontal line
                                ctx.beginPath();
                                ctx.moveTo(xLeft, y);
                                ctx.lineTo(xRight, y);
                                ctx.stroke();

                                // Left cap
                                ctx.beginPath();
                                ctx.moveTo(xLeft, y - capWidth);
                                ctx.lineTo(xLeft, y + capWidth);
                                ctx.stroke();

                                // Right cap
                                ctx.beginPath();
                                ctx.moveTo(xRight, y - capWidth);
                                ctx.lineTo(xRight, y + capWidth);
                                ctx.stroke();
                            }
                        });

                        ctx.restore();
                    }
                };

                // Create new chart
                rotationChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: rotationData.map(d => d.rotation),
                        datasets: [{
                            label: 'Average HPS',
                            data: rotationData.map(d => d.avg),
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const d = rotationData[context.dataIndex];
                                        return `Avg: ${d.avg.toFixed(2)} ± ${d.error.toFixed(2)} HPS (n=${d.count})`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                min: xAxisMin,
                                max: xAxisMax,
                                title: {
                                    display: true,
                                    text: 'Average HPS',
                                    color: '#8b9dc3',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: { color: '#8b9dc3' },
                                grid: { color: 'rgba(139, 157, 195, 0.1)' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Primary Rotation',
                                    color: '#8b9dc3',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: { color: '#8b9dc3' },
                                grid: { color: 'rgba(139, 157, 195, 0.1)' }
                            }
                        }
                    },
                    plugins: [rotationErrorBarPlugin]
                });
            } catch (error) {
                console.error('Error loading rotation chart data:', error);
            }
        }

        // Toggle chart collapse/expand
        function toggleChart(chartId, button) {
            const chartContent = document.getElementById(chartId + 'Content');

            if (chartContent.classList.contains('collapsed')) {
                chartContent.classList.remove('collapsed');
                chartContent.style.maxHeight = chartContent.scrollHeight + 'px';
                button.textContent = 'Collapse';
            } else {
                chartContent.style.maxHeight = chartContent.scrollHeight + 'px';
                setTimeout(() => {
                    chartContent.classList.add('collapsed');
                }, 10);
                button.textContent = 'Expand';
            }
        }

        // Toggle theorycraft section collapse/expand
        function toggleTheorycraft(sectionId, header) {
            const content = document.getElementById(sectionId + 'Content');
            const button = header.querySelector('.theorycraft-toggle');

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                button.textContent = 'Collapse';
            } else {
                content.style.maxHeight = content.scrollHeight + 'px';
                setTimeout(() => {
                    content.classList.add('collapsed');
                }, 10);
                button.textContent = 'Expand';
            }
        }

        // Toggle table collapse/expand
        function toggleTable() {
            const tableContent = document.getElementById('tableContent');
            const collapseBtn = document.getElementById('collapseBtn');

            if (tableContent.classList.contains('collapsed')) {
                tableContent.classList.remove('collapsed');
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
                collapseBtn.textContent = 'Collapse';
            } else {
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
                setTimeout(() => {
                    tableContent.classList.add('collapsed');
                }, 10);
                collapseBtn.textContent = 'Expand';
            }
        }

        // Toggle Data Dictionary collapse/expand
        function toggleDataDictionary() {
            const content = document.getElementById('dataDictContent');
            const btn = document.getElementById('dataDictBtn');

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                btn.textContent = 'Expand';
            } else {
                content.classList.add('expanded');
                btn.textContent = 'Collapse';
            }
        }

        // Update max-height when content changes
        function updateTableHeight() {
            const tableContent = document.getElementById('tableContent');
            if (!tableContent.classList.contains('collapsed')) {
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
            }
        }

        // Global filter state
        let currentFilter = null;

        async function loadTopN() {
            const n = document.getElementById('topN').value || 20;
            const dataset = getDatasetName();
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with optional filters
            let url = `/api/top/${n}?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) {
                url += `&totalHealers=${totalHealers}`;
            }
            if (shadowPriest) {
                url += `&vampiricTouch=${shadowPriest}`;
            }
            if (innervates) {
                url += `&innervates=${innervates}`;
            }
            if (rotatingOnTank) {
                url += `&rotatingOnTank=${rotatingOnTank}`;
            }
            if (nDruid) {
                url += `&nDruid=${nDruid}`;
            }
            if (nPaladin) {
                url += `&nPaladin=${nPaladin}`;
            }
            if (nHPriest) {
                url += `&nHPriest=${nHPriest}`;
            }
            if (nDPriest) {
                url += `&nDPriest=${nDPriest}`;
            }
            if (nShaman) {
                url += `&nShaman=${nShaman}`;
            }
            if (regions) {
                url += `&regions=${regions}`;
            }

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;
                const totalCount = result.total_count;

                const tableBody = document.getElementById('tableBody');

                if (data.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="14" style="text-align: center;">No data available</td></tr>';
                    document.getElementById('filteredCount').textContent = `(0 Filtered Records)`;
                    return;
                }

                tableBody.innerHTML = data.map(row => `
                    <tr>
                        <td>${row.AdjustedRank || 'N/A'}</td>
                        <td><strong>${row.Name || 'N/A'}</strong></td>
                        <td>${row.Server || 'N/A'}</td>
                        <td>${row.Region || 'N/A'}</td>
                        <td>${row.Duration || 'N/A'}</td>
                        <td><strong>${typeof row.HPS === 'number' && !isNaN(row.HPS) ? row.HPS.toFixed(2) : 'N/A'}</strong></td>
                        <td>${typeof row.HasteGear === 'number' && !isNaN(row.HasteGear) && row.HasteGear !== 0 ? row.HasteGear : '-'}</td>
                        <td>${typeof row.Spirit === 'number' && !isNaN(row.Spirit) && row.Spirit !== 0 ? row.Spirit : '-'}</td>
                        <td>${row.TotalHealers || 'N/A'}</td>
                        <td>${typeof row.InnervateCount === 'number' ? row.InnervateCount : 'N/A'}</td>
                        <td>${row.VampiricTouch || 'N/A'}</td>
                        <td>${row.RotatingOnTank || 'N/A'}</td>
                        <td>${row.Rotation1 || 'N/A'}</td>
                        <td>${row.ReportLink ? `<a href="${row.ReportLink}" target="_blank" style="display: inline-block; padding: 6px 12px; background: #2a2d2a; color: #bebeb1; text-decoration: none; border-radius: 4px; font-size: 0.85em; font-weight: 600; border: 1px solid #3a3d3a; transition: all 0.2s;" onmouseover="this.style.background='#3a3d3a'; this.style.color='#fff'" onmouseout="this.style.background='#2a2d2a'; this.style.color='#bebeb1'">View</a>` : 'N/A'}</td>
                    </tr>
                `).join('');

                // Update filtered count with total count from entire filtered dataset
                document.getElementById('filteredCount').textContent = `(${totalCount} Filtered Records)`;

                // Update charts with all filtered data (separate from table)
                updateChart();
                updateHasteChart();
                updateRotationChart();

                // Update table height after loading data
                setTimeout(updateTableHeight, 100);
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('tableBody').innerHTML = '<tr><td colspan="14" style="text-align: center; color: red;">Error loading data</td></tr>';
            }
        }

        // Function to load all data
        function loadData() {
            loadTopN();
        }

        // Function to handle boss selection change
        function onBossChange() {
            const bossSelect = document.getElementById('dataset');
            const phaseContainer = document.getElementById('phaseFilterContainer');

            // Show phase selector for multi-phase encounters (Eredar Twins, M'uru)
            if (bossSelect.value === 'eredar_twins' || bossSelect.value === 'muru') {
                phaseContainer.style.display = '';
            } else {
                phaseContainer.style.display = 'none';
            }

            loadData();
        }

        // Function to get the actual dataset name (handles multi-phase encounters)
        function getDatasetName() {
            const bossSelect = document.getElementById('dataset');
            const boss = bossSelect.value;

            if (boss === 'eredar_twins') {
                const phase = document.getElementById('phaseSelect').value;
                return `eredar_twins_p${phase}`;
            }

            if (boss === 'muru') {
                const phase = document.getElementById('phaseSelect').value;
                return `muru_p${phase}`;
            }

            return boss;
        }

        // Function to set filter and update buttons
        function setFilter(filter, buttonId) {
            // Remove active class from all buttons
            document.querySelectorAll('.icon-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // If clicking the same filter, toggle it off
            if (currentFilter === filter) {
                currentFilter = null;
            } else {
                currentFilter = filter;
                // Add active class to clicked button
                if (buttonId) {
                    document.getElementById(buttonId).classList.add('active');
                }
            }

            // Reload data with new filter
            loadTopN();
        }

        // Load data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Handle initial URL hash to show correct tab
            handleHashChange();

            loadData();

            // Add click handlers to icon buttons
            document.getElementById('treeOfLifeBtn').addEventListener('click', () => {
                setFilter('No', 'treeOfLifeBtn');
            });

            document.getElementById('naturesGraceBtn').addEventListener('click', () => {
                setFilter('Yes', 'naturesGraceBtn');
            });

            // Dreamstate button does nothing for now
            document.getElementById('dreamstateBtn').addEventListener('click', () => {
                // No action yet
            });
        });

        // ===== REPORT ANALYZER FUNCTIONS =====

        async function analyzeReport() {
            const reportCode = document.getElementById('reportCode').value.trim();
            const bossName = document.getElementById('bossName').value.trim();
            const playerName = document.getElementById('playerName').value.trim();

            // Validate inputs
            if (!reportCode || !bossName || !playerName) {
                showAnalyzerError('Please fill in all fields: Report Code, Boss Name, and Player Name.');
                return;
            }

            // Show loading, hide results and error
            document.getElementById('analyzerLoading').style.display = 'block';
            document.getElementById('analyzerResults').style.display = 'none';
            document.getElementById('analyzerError').style.display = 'none';
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analyzeBtn').textContent = 'Analyzing...';

            try {
                const response = await fetch('/api/analyze-report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        report_code: reportCode,
                        boss_name: bossName,
                        player_name: playerName
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Analysis failed');
                }

                displayAnalysisResults(data);

            } catch (error) {
                showAnalyzerError(error.message);
            } finally {
                document.getElementById('analyzerLoading').style.display = 'none';
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('analyzeBtn').textContent = 'Analyze';
            }
        }

        function showAnalyzerError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('analyzerError').style.display = 'block';
            document.getElementById('analyzerResults').style.display = 'none';
        }

        function displayAnalysisResults(data) {
            // Show results container
            document.getElementById('analyzerResults').style.display = 'block';

            // Encounter info
            document.getElementById('resultDate').textContent = data.date;
            document.getElementById('resultDuration').textContent = data.duration;
            document.getElementById('resultHealers').textContent = data.total_healers;

            // Player performance
            document.getElementById('resultPlayerName').textContent = data.player_name;
            const ranking = data.player_ranking || {};
            document.getElementById('resultPlayerServer').textContent =
                ranking.server ? `${ranking.server} (${ranking.region})` : 'Unknown Server';

            const hps = ranking.hps || 0;
            document.getElementById('resultHPS').textContent = hps.toFixed(2);
            document.getElementById('resultRank').textContent =
                ranking.rank ? `Rank ${ranking.rank} of ${ranking.totalParses} (${ranking.rankPercent}th percentile)` : '-';

            // Stats
            const stats = data.player_stats || {};
            document.getElementById('resultIntellect').textContent = stats.has_stats ? stats.intellect : '?';
            document.getElementById('resultSpirit').textContent = stats.has_stats ? stats.spirit : '?';
            document.getElementById('resultHaste').textContent = stats.has_stats ? stats.haste_gear : '?';

            // Buffs
            document.getElementById('resultVT').innerHTML = data.has_vampiric_touch
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';
            document.getElementById('resultInnervate').textContent = data.innervate_count;
            document.getElementById('resultBL').innerHTML = data.has_bloodlust
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';
            document.getElementById('resultNG').innerHTML = data.has_natures_grace
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';

            // Trinkets
            const trinkets = data.player_trinkets || {};
            const trinketList = trinkets.trinkets || [];
            document.getElementById('resultTrinket1').textContent =
                trinketList[0] ? `${trinketList[0].name} (ID: ${trinketList[0].id})` : 'Unknown';
            document.getElementById('resultTrinket2').textContent =
                trinketList[1] ? `${trinketList[1].name} (ID: ${trinketList[1].id})` : 'Unknown';

            // HoT Breakdown
            const totalHPS = hps || 1; // avoid division by zero
            document.getElementById('resultLBHPS').textContent = data.lifebloom_hps.toFixed(2);
            document.getElementById('resultLBPercent').textContent = ((data.lifebloom_hps / totalHPS) * 100).toFixed(1) + '%';
            document.getElementById('resultLBUptime').textContent = `${data.lifebloom_uptime_percent}% uptime`;

            document.getElementById('resultRejuvHPS').textContent = data.rejuvenation_hps.toFixed(2);
            document.getElementById('resultRejuvPercent').textContent = ((data.rejuvenation_hps / totalHPS) * 100).toFixed(1) + '%';

            document.getElementById('resultRGHPS').textContent = data.regrowth_total_hps.toFixed(2);
            document.getElementById('resultRGPercent').textContent = ((data.regrowth_total_hps / totalHPS) * 100).toFixed(1) + '%';

            // Regrowth rank breakdown
            const rgRanks = data.regrowth_by_rank || {};
            const rgRankText = Object.entries(rgRanks)
                .filter(([rank, hps]) => hps > 0)
                .map(([rank, hps]) => `R${rank}: ${hps.toFixed(1)}`)
                .join(', ');
            document.getElementById('resultRGRanks').textContent = rgRankText || '-';

            // Healer Composition
            const healerComp = data.healer_composition || {};
            const healerCompHtml = Object.entries(healerComp).map(([type, players]) => {
                const colorClass = type.includes('Druid') ? 'healer-druid'
                    : type.includes('Paladin') ? 'healer-paladin'
                    : type.includes('Holy Priest') ? 'healer-priest-holy'
                    : type.includes('Discipline') ? 'healer-priest-disc'
                    : type.includes('Shaman') ? 'healer-shaman' : '';

                return `
                    <div style="flex: 1; min-width: 150px;">
                        <div style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 5px;">${type} (${players.length})</div>
                        <div class="${colorClass}" style="font-weight: 600;">
                            ${players.length > 0 ? players.join(', ') : 'None'}
                        </div>
                    </div>
                `;
            }).join('');
            document.getElementById('healerCompList').innerHTML = healerCompHtml;

            // Rotation Analysis
            document.getElementById('resultRotationCount').textContent = data.rotation_count;
            document.getElementById('resultTankRotation').textContent = data.tank_rotation_percent + '%';
            document.getElementById('resultRotatingOnTank').innerHTML = data.rotating_on_tank
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';

            // Rotation patterns table
            const patterns = data.sorted_patterns || [];
            const totalRotations = data.actual_rotations ? data.actual_rotations.length : 1;
            const patternsHtml = patterns.slice(0, 10).map((pattern, index) => {
                const [notation, count] = pattern;
                const percentage = ((count / totalRotations) * 100).toFixed(1);
                return `
                    <tr>
                        <td>${index + 1}</td>
                        <td><strong>${notation}</strong></td>
                        <td>${count}</td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            }).join('');
            document.getElementById('rotationPatternsBody').innerHTML = patternsHtml || '<tr><td colspan="4">No rotation data</td></tr>';

            // Report link
            document.getElementById('reportLink').href = data.report_link;

            // Cast Sequence with proper rotation grouping using rotation_sections
            const castData = data.cast_data || [];
            const rotationSections = data.rotation_sections || [];
            document.getElementById('castCount').textContent = `(${castData.length} casts)`;

            // Check if a section is "interesting" (same logic as actual_rotations filter in Python)
            function isInterestingSection(section) {
                // Filter out: [1LB 0I 0RG] (just rotation start) and [0LB 1I 0RG] (just instant cast)
                const isJustRotationStart = (section.lb === 1 && section.i === 0 && section.rg === 0);
                const isJustInstantCast = (section.lb === 0 && section.i === 1 && section.rg === 0);
                return !isJustRotationStart && !isJustInstantCast;
            }

            // Function to find which section a cast belongs to based on time
            function findSectionIndex(time) {
                for (let i = 0; i < rotationSections.length; i++) {
                    const section = rotationSections[i];
                    // For last section, include end_time; otherwise exclude it
                    const isLastSection = (i === rotationSections.length - 1);
                    if (time >= section.start_time && (isLastSection ? time <= section.end_time : time < section.end_time)) {
                        return i;
                    }
                }
                return -1;
            }

            let lastSectionIndex = -1;
            let displayedRotationNumber = 0;
            const castSequenceHtml = castData.map((cast, index) => {
                // Find which section this cast belongs to
                const sectionIndex = findSectionIndex(cast.time);

                // Skip casts from uninteresting sections entirely
                if (sectionIndex >= 0 && !isInterestingSection(rotationSections[sectionIndex])) {
                    return '';  // Don't render this cast
                }

                // Determine action string
                let actionStr = '';
                if (cast.rotation_start) {
                    actionStr = '<span style="color: #10b981; font-weight: 600;">Rotation started</span>';
                } else if (cast.instant_cast) {
                    actionStr = 'Instant cast';
                } else if (cast.regrowth) {
                    actionStr = 'Regrowth';
                } else {
                    actionStr = '-';
                }

                // Highlight lifebloom on tank
                const spellStyle = cast.rotation_start ? 'color: #10b981; font-weight: 600;' : '';

                let separatorRow = '';

                // Add separator when entering a new section
                if (sectionIndex !== lastSectionIndex && sectionIndex >= 0) {
                    displayedRotationNumber++;
                    const section = rotationSections[sectionIndex];
                    const notation = `[${section.lb}LB ${section.i}I ${section.rg}RG]`;
                    separatorRow = `
                        <tr style="background: #0f3460; border-top: 2px solid #667eea;">
                            <td colspan="5" style="padding: 8px; color: #667eea; font-weight: 600; text-align: center;">
                                Rotation #${displayedRotationNumber} &nbsp;—&nbsp; ${notation}
                            </td>
                        </tr>
                    `;
                    lastSectionIndex = sectionIndex;
                }

                return `
                    ${separatorRow}
                    <tr>
                        <td>${cast.time.toFixed(2)}s</td>
                        <td style="${spellStyle}">${cast.spell}</td>
                        <td>${cast.target}</td>
                        <td style="color: #C41E3A;">${cast.active_tank}</td>
                        <td>${actionStr}</td>
                    </tr>
                `;
            }).join('');
            document.getElementById('castSequenceBody').innerHTML = castSequenceHtml || '<tr><td colspan="5">No cast data</td></tr>';
        }

        function toggleRotationTable() {
            const content = document.getElementById('rotationTableContent');
            const btn = content.previousElementSibling.previousElementSibling.querySelector('.collapse-btn');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = 'Collapse';
            } else {
                content.style.display = 'none';
                btn.textContent = 'Expand';
            }
        }

        function toggleCastSequence() {
            const content = document.getElementById('castSequenceContent');
            const btn = document.getElementById('castSequenceCollapseBtn');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = 'Collapse';
            } else {
                content.style.display = 'none';
                btn.textContent = 'Expand';
            }
        }

        // Allow Enter key to submit the form
        document.addEventListener('DOMContentLoaded', function() {
            ['reportCode', 'bossName', 'playerName'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            analyzeReport();
                        }
                    });
                }
            });
        });

        // Haste Breakpoint Chart
        let hasteBreakpointChart = null;

        function initHasteBreakpointChart() {
            const ctx = document.getElementById('hasteBreakpointChart');
            if (!ctx) return;

            // Rotation data with haste values at different latencies (Model B: latency added per action)
            const rotationData = [
                { rotation: '[1LB 1I 1RG]', haste: { 0: 0, 50: 0, 100: 0, 150: 0, 200: 0, 250: 0, 300: 0 }, tier: 'Baseline' },
                { rotation: '[1LB 0I 2RG]', haste: { 0: 0, 50: 0, 100: 0, 150: 0, 200: 0, 250: 0, 300: 0 }, tier: 'Baseline' },
                { rotation: '[1LB 3I 0RG]', haste: { 0: 0, 50: 0, 100: 0, 150: 0, 200: 0, 250: 0, 300: 54 }, tier: 'Baseline' },
                { rotation: '[1LB 2I 1RG]', haste: { 0: 0, 50: 0, 100: 0, 150: 25, 200: 76, 250: 131, 300: 190 }, tier: 'Baseline' },
                { rotation: '[1LB 1I 2RG]', haste: { 0: 0, 50: 46, 100: 96, 150: 148, 200: 203, 250: 263, 300: 326 }, tier: 'Pre-Raid' },
                { rotation: '[1LB 4I 0RG]', haste: { 0: 112, 50: 175, 100: 243, 150: 315, 200: 394, 250: 479, 300: 574 }, tier: 'Hyjal/BT' },
                { rotation: '[1LB 0I 3RG]', haste: { 0: 112, 50: 162, 100: 214, 150: 271, 200: 331, 250: 394, 300: 462 }, tier: 'Hyjal/BT' },
                { rotation: '[1LB 3I 1RG]', haste: { 0: 225, 50: 292, 100: 364, 150: 441, 200: 525, 250: 616, 300: 717 }, tier: 'Zul\'Aman' },
                { rotation: '[1LB 2I 2RG]', haste: { 0: 337, 50: 408, 100: 486, 150: 568, 200: 657, 250: 754, 300: 859 }, tier: 'Sunwell' },
                { rotation: '[1LB 5I 0RG]', haste: { 0: 451, 50: 541, 100: 640, 150: 749, 200: 870, 250: 1003, 300: 1152 }, tier: 'Sunwell' },
                { rotation: '[1LB 1I 3RG]', haste: { 0: 451, 50: 525, 100: 607, 150: 694, 200: 789, 250: 891, 300: 1003 }, tier: 'Sunwell' },
            ];

            // Color mapping by haste value
            const hasteColors = {
                'Hyjal/BT': { bg: 'rgba(163, 53, 238, 0.7)', border: 'rgba(163, 53, 238, 1)' },
                'Zul\'Aman': { bg: 'rgba(255, 215, 0, 0.7)', border: 'rgba(255, 215, 0, 1)' },
                'Sunwell': { bg: 'rgba(255, 128, 0, 0.7)', border: 'rgba(255, 128, 0, 1)' },
                'Bloodlust': { bg: 'rgba(220, 20, 60, 0.7)', border: 'rgba(220, 20, 60, 1)' },
            };

            // Function to get color based on haste value
            function getColorForHaste(haste) {
                if (haste <= 230) return hasteColors['Hyjal/BT'];
                if (haste <= 300) return hasteColors['Zul\'Aman'];
                if (haste <= 500) return hasteColors['Sunwell'];
                return hasteColors['Bloodlust'];
            }

            // Function to get tier name based on haste value
            function getTierForHaste(haste) {
                if (haste <= 230) return 'Hyjal/BT';
                if (haste <= 300) return 'Zul\'Aman';
                if (haste <= 500) return 'Sunwell';
                return 'Bloodlust Only';
            }

            // Function to get haste value for a given latency (interpolate if needed)
            function getHasteForLatency(data, latency) {
                // Round to nearest known value
                const knownLatencies = [0, 50, 100, 150, 200, 250, 300];
                let closest = knownLatencies.reduce((prev, curr) =>
                    Math.abs(curr - latency) < Math.abs(prev - latency) ? curr : prev
                );
                return data.haste[closest];
            }

            // Function to update chart with new latency
            function updateChart(latency) {
                if (!hasteBreakpointChart) return;

                const newData = rotationData.map(d => getHasteForLatency(d, latency));
                hasteBreakpointChart.data.datasets[0].data = newData;
                // Update bar colors based on haste values
                hasteBreakpointChart.data.datasets[0].backgroundColor = newData.map(h => getColorForHaste(h).bg);
                hasteBreakpointChart.data.datasets[0].borderColor = newData.map(h => getColorForHaste(h).border);
                // Dynamically adjust x-axis max based on highest haste value
                const maxHaste = Math.max(...newData);
                hasteBreakpointChart.options.scales.x.max = Math.ceil((maxHaste + 50) / 100) * 100;
                hasteBreakpointChart.update();
            }

            hasteBreakpointChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: rotationData.map(d => d.rotation),
                    datasets: [{
                        label: 'Haste Required',
                        data: rotationData.map(d => d.haste[0]),
                        backgroundColor: rotationData.map(d => getColorForHaste(d.haste[0]).bg),
                        borderColor: rotationData.map(d => getColorForHaste(d.haste[0]).border),
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const data = rotationData[context.dataIndex];
                                    const latency = parseInt(document.getElementById('latencySlider')?.value || 0);
                                    const haste = getHasteForLatency(data, latency);
                                    return `${haste} Haste (${getTierForHaste(haste)})`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 500,
                            title: {
                                display: true,
                                text: 'Haste Rating',
                                color: '#c9d1d9'
                            },
                            ticks: {
                                color: '#8b949e'
                            },
                            grid: {
                                color: 'rgba(139, 148, 158, 0.2)'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#c9d1d9',
                                font: {
                                    family: 'monospace'
                                }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });

            // Set up latency slider
            const slider = document.getElementById('latencySlider');
            const latencyValue = document.getElementById('latencyValue');

            if (slider && latencyValue) {
                slider.addEventListener('input', function() {
                    const latency = parseInt(this.value);
                    latencyValue.textContent = latency + 'ms';
                    updateChart(latency);
                });
            }
        }

        // Initialize chart when DOM is ready
        document.addEventListener('DOMContentLoaded', initHasteBreakpointChart);
    </script>
</body>
</html>
