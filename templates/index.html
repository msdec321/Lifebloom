<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lifebloom - A Restoration Druid Analysis Tool</title>
    <link rel="icon" type="image/jpeg" href="/static/icons/lifebloom.jpg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #262626;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            color: #eee;
            display: flex;
        }

        .sidebar {
            width: 200px;
            background: #1d1f1c;
            border-right: 2px solid #2a3f5f;
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .sidebar-tab {
            padding: 15px 25px;
            cursor: pointer;
            color: #bebeb1;
            font-weight: 600;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .sidebar-tab:hover {
            background: #262626;
            color: #fff;
        }

        .sidebar-tab.active {
            background: #262626;
            color: #fff;
            border-left-color: #667eea;
        }

        .main-content {
            margin-left: 200px;
            flex: 1;
            padding: 20px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .druid-text {
            color: #DE772A;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s;
            border: 1px solid #2a3f5f;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
            border-color: #667eea;
        }

        .stat-card h3 {
            color: #bebeb1;
            font-size: 0.9em;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .table-container {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            overflow-x: auto;
            border: 1px solid #2a3f5f;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .table-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #bebeb1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .filtered-count {
            font-size: 0.9em;
            color: #DE772A;
            font-weight: 500;
        }

        .table-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table-controls label {
            color: #eee;
            font-weight: 600;
        }

        .table-controls input {
            padding: 8px 12px;
            border: 1px solid #3a3d3a;
            border-radius: 5px;
            font-size: 1em;
            width: 80px;
            background: #2a2d2a;
            color: #bebeb1;
        }

        .table-controls input:focus {
            outline: none;
            border-color: #4a4d4a;
            background: #3a3d3a;
        }

        .table-controls button {
            padding: 8px 16px;
            background: #2a2d2a;
            color: #bebeb1;
            border: 1px solid #3a3d3a;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .table-controls button:hover {
            background: #3a3d3a;
            color: #fff;
            border-color: #4a4d4a;
        }

        .collapse-btn {
            background: #2a2d2a;
            border: 1px solid #3a3d3a;
            border-radius: 5px;
            padding: 8px 16px;
            color: #bebeb1;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .collapse-btn:hover {
            background: #3a3d3a;
            color: #fff;
            border-color: #4a4d4a;
        }

        .table-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
        }

        .table-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background: #16213e;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #8b9dc3;
        }

        .chart-container canvas {
            max-height: 400px;
        }

        .chart-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .chart-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .chart-collapse-btn {
            background: #2a3f5f;
            color: #8b9dc3;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .chart-collapse-btn:hover {
            background: #3a4f6f;
            color: #fff;
        }

        #rotationChartContent {
            height: 400px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #2a2d2a;
            color: #bebeb1;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #2a3f5f;
            color: #eee;
        }

        th {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 0.5px;
        }

        tbody tr:hover {
            background-color: #1f2d47;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #8b9dc3;
            font-size: 1.2em;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-yes {
            background-color: #10b981;
            color: white;
        }

        .badge-no {
            background-color: #ef4444;
            color: white;
        }

        .controls {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .controls-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #bebeb1;
            margin-bottom: 20px;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .filter-section-title {
            color: #8b9dc3;
            font-weight: 600;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a3f5f;
            margin-bottom: 5px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filter-item label {
            font-weight: 600;
            color: #eee;
            min-width: 120px;
            font-size: 0.9em;
        }

        .filter-item select,
        .filter-item input {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            font-size: 0.9em;
            background: #2d2d2d;
            color: #fff;
            min-width: 0;
        }

        .filter-item select {
            cursor: pointer;
        }

        .filter-item select:focus,
        .filter-item input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #667eea40;
            border-color: #667eea;
        }

        .healer-comp-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .region-checkboxes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 8px;
            max-width: 150px;
        }

        .region-checkboxes label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: #eee;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .region-checkboxes input[type="checkbox"] {
            cursor: pointer;
        }

        .icon-buttons {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin-bottom: 30px;
        }

        .icon-button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .icon-label {
            color: #39c07f;
            font-size: 0.9em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .icon-button {
            background: #16213e;
            border: 2px solid #2a3f5f;
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-button:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.3);
        }

        .icon-button.active {
            border-color: #667eea;
            background: #0f3460;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .icon-button img {
            width: 44px;
            height: 44px;
            border-radius: 5px;
        }

        .notice-banner {
            background: #1d1f1c;
            border: 1px solid #2a3f5f;
            border-radius: 10px;
            padding: 20px 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .notice-banner h3 {
            color: #bebeb1;
            font-size: 1.1em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .notice-banner p {
            color: #c5d0e6;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .notice-banner p:last-child {
            margin-bottom: 0;
        }

        .notice-banner .signature {
            color: #8b9dc3;
            font-style: italic;
            margin-top: 15px;
        }

        .section-divider {
            border: none;
            border-top: 1px solid #2a3f5f;
            margin: 25px 0;
        }

        .region-grid {
            display: grid;
            grid-template-columns: repeat(2, auto);
            gap: 5px 15px;
            margin-left: 5px;
        }

        .region-grid label {
            cursor: pointer;
            display: flex;
            align-items: center;
        }

        .region-grid input {
            margin: 0;
            cursor: pointer;
        }

        .about-section {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px 30px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .about-section h2 {
            color: #bebeb1;
            font-size: 1.3em;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .about-section p {
            color: #c5d0e6;
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .about-section.justified p {
            text-align: justify;
        }

        .about-section p:last-child {
            margin-bottom: 0;
        }

        .author-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .author-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid #667eea;
            object-fit: cover;
        }

        .author-name {
            color: #fff;
            font-size: 1.5em;
            font-weight: 600;
        }

        .contact-links {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .contact-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #0f3460;
            border: 1px solid #2a3f5f;
            border-radius: 6px;
            color: #c5d0e6;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
        }

        .contact-link:hover {
            border-color: #667eea;
            background: #1a3f6f;
            color: #fff;
        }

        .contact-link.discord {
            cursor: default;
        }

        .author-section {
            display: flex;
            gap: 25px;
        }

        .author-section .author-avatar {
            flex-shrink: 0;
        }

        .author-content {
            flex: 1;
        }

        .author-content h2 {
            margin-top: 0;
        }

        .about-section ul {
            color: #c5d0e6;
            line-height: 1.7;
            margin: 15px 0;
            padding-left: 25px;
        }

        .about-section li {
            margin-bottom: 8px;
        }

        .about-section em {
            color: #667eea;
            font-style: italic;
        }

        /* Loading spinner */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #2a3f5f;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Healer class colors */
        .healer-druid { color: #FF7C0A; }
        .healer-paladin { color: #F48CBA; }
        .healer-priest-holy { color: #FFFFFF; }
        .healer-priest-disc { color: #FFFFFF; }
        .healer-shaman { color: #0070DD; }

        /* Tank class color */
        .tank-badge {
            display: inline-block;
            padding: 6px 12px;
            background: #0f3460;
            border: 1px solid #2a3f5f;
            border-radius: 5px;
            color: #C41E3A;
            font-weight: 600;
        }

        /* Data Dictionary styles */
        .data-dictionary {
            background: #1d1f1c;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #2a3f5f;
        }

        .data-dictionary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .data-dictionary-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #bebeb1;
        }

        .data-dictionary-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out;
            opacity: 0;
            margin-top: 0;
        }

        .data-dictionary-content.expanded {
            max-height: 2000px;
            opacity: 1;
            margin-top: 20px;
        }

        .dict-category {
            margin-bottom: 25px;
        }

        .dict-category:last-child {
            margin-bottom: 0;
        }

        .dict-category-title {
            color: #8b9dc3;
            font-weight: 600;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a3f5f;
            margin-bottom: 15px;
        }

        .dict-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .dict-item {
            background: #262626;
            border-radius: 6px;
            padding: 12px 15px;
            border-left: 3px solid #667eea;
        }

        .dict-term {
            color: #DE772A;
            font-weight: 600;
            font-size: 0.95em;
            margin-bottom: 5px;
        }

        .dict-definition {
            color: #c5d0e6;
            font-size: 0.9em;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-tab active" onclick="switchTab('analysis')">Analysis Tool</div>
        <div class="sidebar-tab" onclick="switchTab('report')">Report Analyzer</div>
        <div class="sidebar-tab" onclick="switchTab('theorycrafting')">Community Theorycrafting</div>
        <div class="sidebar-tab" onclick="switchTab('about')">About</div>
    </div>

    <div class="main-content">
        <!-- Analysis Tool Tab -->
        <div id="analysisTab" class="tab-content active">
            <div class="container">
                <h1 id="pageTitle">Lifebloom - A Restoration <span class="druid-text">Druid</span> Analysis Tool</h1>

                <div class="notice-banner">
                    <h3>Notice</h3>
                    <p>Welcome to <span style="color: #39c07f; font-weight: 600;">Lifebloom</span>! This is an application that collects and structures TBC Resto Druid data from WarcraftLogs in order to help facilitate retrospective data analyses by and for the community. This app is still in development in preparation for the next iteration of TBC Classic.</p>
                    <p>For more information about the tool and how to contact the author, please check out the "About" tab. Thanks!</p>
                    <p class="signature">- Mercy</p>
                </div>

                <hr class="section-divider">

        <div class="icon-buttons">
            <div class="icon-button-container">
                <div class="icon-label">Deep Resto</div>
                <button class="icon-button" id="treeOfLifeBtn">
                    <img src="/static/icons/treeoflife.jpg" alt="Tree of Life">
                </button>
            </div>
            <div class="icon-button-container">
                <div class="icon-label">Dreamstate</div>
                <button class="icon-button" id="dreamstateBtn">
                    <img src="/static/icons/dreamstate.jpg" alt="Dreamstate">
                </button>
            </div>
            <div class="icon-button-container">
                <div class="icon-label">Nature's Grace</div>
                <button class="icon-button" id="naturesGraceBtn">
                    <img src="/static/icons/naturesgrace.jpg" alt="Nature's Grace">
                </button>
            </div>
        </div>

        <div class="controls">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <div class="controls-title" style="margin-bottom: 0;">Filters</div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: #ddd; font-size: 0.9em;">
                        <input type="radio" name="dataSource" value="best" checked onchange="loadData()">
                        <span>Best report per player</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; color: #ddd; font-size: 0.9em;">
                        <input type="radio" name="dataSource" value="all" onchange="loadData()">
                        <span>All reports per player</span>
                    </label>
                </div>
            </div>
            <p style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 15px;">For descriptions of each variable in the dataset and a definition of Rotation, please see the Data Dictionary section below.</p>
            <div class="filter-grid">
                <!-- Fight Settings Section -->
                <div class="filter-section">
                    <div class="filter-section-title">Fight Settings</div>
                    <div class="filter-item">
                        <label for="dataset">Boss:</label>
                        <select id="dataset" onchange="loadData()">
                            <option value="brutallus">Brutallus</option>
                            <option value="felmyst">Felmyst</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="totalHealers">Total Healers:</label>
                        <select id="totalHealers" onchange="loadTopN()">
                            <option value="">Any</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="rotatingOnTank">Rotating on Tank:</label>
                        <select id="rotatingOnTank" onchange="loadTopN()">
                            <option value="">Any</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                </div>

                <!-- Buffs & Support Section -->
                <div class="filter-section">
                    <div class="filter-section-title">Buffs & Support</div>
                    <div class="filter-item">
                        <label for="shadowPriest">Shadow Priest:</label>
                        <select id="shadowPriest" onchange="loadTopN()">
                            <option value="">Any</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="innervates">Innervates:</label>
                        <select id="innervates" onchange="loadTopN()">
                            <option value="" selected>Any</option>
                            <option value="0">0</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>
                    </div>
                    <div style="margin-top: 20px;">
                        <div style="color: #eee; font-weight: 600; font-size: 0.9em; margin-bottom: 8px;">Region:</div>
                        <div class="region-checkboxes" style="margin-left: 10px;">
                            <label><input type="checkbox" id="regionUS" value="US" checked onchange="loadTopN()"> US</label>
                            <label><input type="checkbox" id="regionEU" value="EU" checked onchange="loadTopN()"> EU</label>
                            <label><input type="checkbox" id="regionCN" value="CN" checked onchange="loadTopN()"> CN</label>
                            <label><input type="checkbox" id="regionKR" value="KR" checked onchange="loadTopN()"> KR</label>
                        </div>
                    </div>
                </div>

                <!-- Healer Composition Section -->
                <div class="filter-section">
                    <div class="filter-section-title">Healer Composition</div>
                    <div class="healer-comp-grid">
                        <div class="filter-item">
                            <label for="nDruid">Druids:</label>
                            <select id="nDruid" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nPaladin">Paladins:</label>
                            <select id="nPaladin" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nHPriest">Holy Priests:</label>
                            <select id="nHPriest" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nDPriest">Disc Priests:</label>
                            <select id="nDPriest" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label for="nShaman">Shamans:</label>
                            <select id="nShaman" onchange="loadTopN()">
                                <option value="">Any</option>
                                <option value="0">0</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">HPS vs Haste</div>
                    <button class="chart-collapse-btn" onclick="toggleChart('hasteChart', this)">Collapse</button>
                </div>
                <div class="chart-content" id="hasteChartContent">
                    <canvas id="hasteChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">Average HPS by Primary Rotation</div>
                    <button class="chart-collapse-btn" onclick="toggleChart('rotationChart', this)">Collapse</button>
                </div>
                <div class="chart-content" id="rotationChartContent">
                    <canvas id="rotationChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">HPS vs Duration</div>
                    <button class="chart-collapse-btn" onclick="toggleChart('hpsChart', this)">Expand</button>
                </div>
                <div class="chart-content collapsed" id="hpsChartContent">
                    <canvas id="hpsChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Data Dictionary Section -->
        <div class="data-dictionary">
            <div class="data-dictionary-header" onclick="toggleDataDictionary()">
                <div class="data-dictionary-title">Data Dictionary</div>
                <button class="collapse-btn" id="dataDictBtn">Expand</button>
            </div>
            <div class="data-dictionary-content" id="dataDictContent">
                <!-- Player Information -->
                <div class="dict-category">
                    <div class="dict-category-title">Player Information</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Name</div>
                            <div class="dict-definition">The character name of the Restoration Druid as it appears on WarcraftLogs.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Server</div>
                            <div class="dict-definition">The realm/server where the character is located.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Region</div>
                            <div class="dict-definition">Geographic region of the server: US (Americas), EU (Europe), CN (China), or KR (Korea).</div>
                        </div>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="dict-category">
                    <div class="dict-category-title">Performance Metrics</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">HPS</div>
                            <div class="dict-definition">Healing Per Second. Total effective healing done divided by fight duration. This is the primary performance metric used for ranking.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Duration</div>
                            <div class="dict-definition">Total length of the boss encounter from pull to kill, displayed in minutes and seconds (e.g., "4m 24s").</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Adjusted Rank</div>
                            <div class="dict-definition">The player's position within the current filtered dataset. Changes dynamically based on active filters.</div>
                        </div>
                    </div>
                </div>

                <!-- Character Stats -->
                <div class="dict-category">
                    <div class="dict-category-title">Character Stats</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Haste</div>
                            <div class="dict-definition">Spell Haste rating at the start of the encounter. Is sometimes unavailable in a report, represented by "-".</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Spirit</div>
                            <div class="dict-definition">Spirit stat at the start of the encounter. Is sometimes unavailable in a report, represented by "-".</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Intellect</div>
                            <div class="dict-definition">Intellect stat at the start of the encounter. Is sometimes unavailable in a report, represented by "-".</div>
                        </div>
                    </div>
                </div>

                <!-- Raid Composition -->
                <div class="dict-category">
                    <div class="dict-category-title">Raid Composition</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Total Healers</div>
                            <div class="dict-definition">Number of healers in the raid.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">nDruid / nPaladin / etc.</div>
                            <div class="dict-definition">Count of each healer class in the raid.</div>
                        </div>
                    </div>
                </div>

                <!-- Buffs & External Support -->
                <div class="dict-category">
                    <div class="dict-category-title">Buffs & External Support</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Shadow Priest (Vampiric Touch)</div>
                            <div class="dict-definition">Whether the Druid had a Shadow Priest providing Vampiric Touch mana regeneration at any point during the encounter.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Innervates</div>
                            <div class="dict-definition">Number of Innervates received during the encounter.</div>
                        </div>
                    </div>
                </div>

                <!-- Playstyle & Rotation -->
                <div class="dict-category">
                    <div class="dict-category-title">Playstyle & Rotation</div>
                    <div class="dict-item" style="margin-bottom: 15px;">
                        <div class="dict-term">Rotation</div>
                        <div class="dict-definition">
                            <p style="margin-bottom: 10px;">A "rotation" is the sequence of spells that the Druid casts, either while maintaining Lifebloom on the tank(s) or not. For an introductory overview on rotations, I'd refer you to SixPacKyx's <a href="https://www.wowhead.com/tbc/guide/classes/druid/healer-rotation-cooldowns-abilities-pve" target="_blank" style="color: #667eea;">WowHead guide</a> under the "Rolling Lifebloom: Advanced Restoration Druid Healing Rotation" section, and additionally giansm's <a href="https://web.archive.org/web/20080913120521/http://elitistjerks.com/f31/t17783-druid_raiding_tree/#Healing_Strategies" target="_blank" style="color: #667eea;">Elitist Jerks guide</a> under the "Healing Strategies" section.</p>
                            <p style="margin-bottom: 10px;">To help discuss rotations more easily, I've created a standard notation for rotations: <strong style="color: #DE772A;">xLB yI zRG</strong></p>
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li><strong>x:</strong> The number of tanks you are rolling Lifebloom on during a rotation.</li>
                                <li><strong>y:</strong> The number of instant cast spells used during a rotation (Rejuv, Swiftmend, Lifebloom on non-tanks, etc.)</li>
                                <li><strong>z:</strong> The number of Regrowth casts used during the rotation.</li>
                            </ul>
                            <p style="margin-top: 15px; margin-bottom: 10px;">To illustrate, here are a few examples:</p>
                            <ul style="margin-left: 20px;">
                                <li><strong style="color: #DE772A;">1LB 1I 1RG</strong> - A typical unhasted 1 tank rotation. The Druid refreshes Lifebloom on the tank, uses an instant cast spell (perhaps refreshing Rejuv on the tank), and casts 1 Regrowth.</li>
                                <li><strong style="color: #DE772A;">2LB 2I 0RG</strong> - A typical unhasted 2 tank rotation. The Druid refreshes Lifebloom on two tanks and uses two instant cast spells, but does not cast any Regrowths.</li>
                                <li><strong style="color: #DE772A;">0LB 0I 5RG</strong> - The Druid does not cast Lifebloom on any tank, but instead casts Regrowth five times in a row.</li>
                            </ul>
                        </div>
                    </div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Rotating on Tank</div>
                            <div class="dict-definition">We programatically list all of the rotations the Druid did over the course of the encounter, and check if at least 70% (chosen arbitrarily) of the Druid's rotations on a fight include a Lifebloom on at least one of the tanks (see Report Analyzer tool for more details). If so, then Rotating on Tank is "Yes", otherwise "No".</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Primary Rotation</div>
                            <div class="dict-definition">The most frequently used rotation pattern during the encounter.</div>
                        </div>
                    </div>
                </div>

                <!-- Talents -->
                <div class="dict-category">
                    <div class="dict-category-title">Talents & Spec</div>
                    <div class="dict-grid">
                        <div class="dict-item">
                            <div class="dict-term">Deep Resto / Tree of Life</div>
                            <div class="dict-definition">Full Restoration spec with Tree of Life form. Provides better mana efficiency and rotational flexibility compared to Dreamstate and Nautre's Grace.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Dreamstate</div>
                            <div class="dict-definition">Hybrid spec investing in Balance for "Improved Faerie Fire", though called Dreamstate for historical reasons. In this spec, Druids sacrifice Tree of Life and Swiftmend.</div>
                        </div>
                        <div class="dict-item">
                            <div class="dict-term">Nature's Grace</div>
                            <div class="dict-definition">Balance talent that reduces next cast time by 0.5s after a spell crit, supporting a Regrowth-heavy playstyle with considerably high HPS but with significant mana constraints. In WarcraftLogs, Deep Resto and Nature's Grace are both categorized as Restoration. To identify Nature's Grace builds, we check if the Druid had the Nature's Grace buff at any point during the encounter.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="table-container">
            <div class="table-header">
                <div class="table-title">
                    <span>Rankings</span>
                    <span class="filtered-count" id="filteredCount"></span>
                </div>
                <div class="table-controls">
                    <label for="topN">Show Top:</label>
                    <input type="number" id="topN" value="20" min="1" max="100">
                    <button onclick="loadTopN()">Update</button>
                    <button class="collapse-btn" id="collapseBtn" onclick="toggleTable()">Collapse</button>
                </div>
            </div>
            <div class="table-content" id="tableContent">
                <table id="dataTable">
                <thead>
                    <tr>
                        <th>Adjusted<br>Rank</th>
                        <th>Name</th>
                        <th>Server</th>
                        <th>Region</th>
                        <th>Duration</th>
                        <th>HPS</th>
                        <th>Haste</th>
                        <th>Spirit</th>
                        <th>Total<br>Healers</th>
                        <th>Innervates</th>
                        <th>Shadow<br>Priest</th>
                        <th>Rotating<br>on Tank</th>
                        <th>Primary<br>Rotation</th>
                        <th>Report<br>Link</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <tr>
                        <td colspan="14" class="loading">Loading data...</td>
                    </tr>
                </tbody>
            </table>
            </div>
        </div>
            </div>
        </div>

        <!-- Report Analyzer Tab -->
        <div id="reportTab" class="tab-content">
            <div class="container">
                <h1>Report Analyzer</h1>

                <div class="notice-banner">
                    <h3>Analyze Individual Reports</h3>
                    <p>Enter a WarcraftLogs report code (or full URL), the boss name, and the Restoration Druid's name to get a comprehensive performance analysis including rotation patterns, buff tracking, and HPS breakdown.</p>
                </div>

                <hr class="section-divider">

                <!-- Input Form -->
                <div class="controls" id="analyzerForm">
                    <div class="controls-title">Report Details</div>
                    <div class="controls-row" style="flex-wrap: wrap; gap: 15px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="reportCode">Report Code/URL:</label>
                            <input type="text" id="reportCode" placeholder="e.g., wX7H9RtYJ48P1cdW" style="width: 280px;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="bossName">Boss:</label>
                            <select id="bossName" style="width: 180px;">
                                <option value="Brutallus">Brutallus</option>
                                <option value="Felmyst">Felmyst</option>
                                <option value="Eredar Twins">Eredar Twins</option>
                                <option value="M'uru">M'uru</option>
                                <option value="Kil'jaeden">Kil'jaeden</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label for="playerName">Player Name:</label>
                            <input type="text" id="playerName" placeholder="e.g., Mercychann" style="width: 180px;">
                        </div>
                        <button onclick="analyzeReport()" id="analyzeBtn">Analyze</button>
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="analyzerLoading" style="display: none; text-align: center; padding: 40px;">
                    <div style="color: #667eea; font-size: 1.2em; margin-bottom: 10px;">Analyzing report...</div>
                    <div style="color: #8b9dc3;">This may take 10-30 seconds depending on the report</div>
                    <div class="loading-spinner" style="margin-top: 20px;"></div>
                </div>

                <!-- Error Display -->
                <div id="analyzerError" style="display: none;" class="notice-banner" style="border-color: #ef4444;">
                    <h3 style="color: #ef4444;">Error</h3>
                    <p id="errorMessage" style="color: #fca5a5;"></p>
                </div>

                <!-- Results Container -->
                <div id="analyzerResults" style="display: none;">
                    <!-- Encounter Info -->
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Encounter Date</h3>
                            <div class="value" id="resultDate">-</div>
                        </div>
                        <div class="stat-card">
                            <h3>Duration</h3>
                            <div class="value" id="resultDuration">-</div>
                        </div>
                        <div class="stat-card">
                            <h3>Total Healers</h3>
                            <div class="value" id="resultHealers">-</div>
                        </div>
                    </div>

                    <!-- Player Performance -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Player Performance</div>
                            <a id="reportLink" href="#" target="_blank" style="padding: 8px 16px; background: #667eea; color: white; text-decoration: none; border-radius: 5px; font-weight: 600;">View on WarcraftLogs</a>
                        </div>
                        <div class="stats-grid" style="margin-bottom: 0;">
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Player</h3>
                                <div class="value" style="font-size: 1.5em;" id="resultPlayerName">-</div>
                                <div style="color: #8b9dc3; margin-top: 5px;" id="resultPlayerServer">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>HPS</h3>
                                <div class="value" style="color: #10b981;" id="resultHPS">-</div>
                                <div style="color: #8b9dc3; margin-top: 5px;" id="resultRank">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Stats</h3>
                                <div style="color: #fff; font-size: 1em;">
                                    <span id="resultIntellect">-</span> Int |
                                    <span id="resultSpirit">-</span> Spirit |
                                    <span id="resultHaste">-</span> Haste
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Buffs & Resources -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Buffs & Resources</div>
                        </div>
                        <div class="stats-grid" style="margin-bottom: 0;">
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Vampiric Touch</h3>
                                <div id="resultVT">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Innervate Count</h3>
                                <div class="value" id="resultInnervate">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Bloodlust/Heroism</h3>
                                <div id="resultBL">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Nature's Grace</h3>
                                <div id="resultNG">-</div>
                            </div>
                        </div>
                    </div>

                    <!-- Trinkets -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Trinkets</div>
                        </div>
                        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 200px;">
                                <div style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 5px;">Trinket 1</div>
                                <div style="color: #fff; font-weight: 600;" id="resultTrinket1">-</div>
                            </div>
                            <div style="flex: 1; min-width: 200px;">
                                <div style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 5px;">Trinket 2</div>
                                <div style="color: #fff; font-weight: 600;" id="resultTrinket2">-</div>
                            </div>
                        </div>
                    </div>

                    <!-- HoT Breakdown -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">HoT Breakdown</div>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th>Spell</th>
                                    <th>HPS</th>
                                    <th>% of Total</th>
                                    <th>Details</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong style="color: #10b981;">Lifebloom</strong></td>
                                    <td id="resultLBHPS">-</td>
                                    <td id="resultLBPercent">-</td>
                                    <td id="resultLBUptime">-</td>
                                </tr>
                                <tr>
                                    <td><strong style="color: #f472b6;">Rejuvenation</strong></td>
                                    <td id="resultRejuvHPS">-</td>
                                    <td id="resultRejuvPercent">-</td>
                                    <td>-</td>
                                </tr>
                                <tr>
                                    <td><strong style="color: #60a5fa;">Regrowth</strong></td>
                                    <td id="resultRGHPS">-</td>
                                    <td id="resultRGPercent">-</td>
                                    <td id="resultRGRanks">-</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Healer Composition -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Healer Composition</div>
                        </div>
                        <div id="healerCompList" style="display: flex; flex-wrap: wrap; gap: 20px;"></div>
                    </div>

                    <!-- Rotation Analysis -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">Rotation Analysis</div>
                            <button class="collapse-btn" onclick="toggleRotationTable()">Collapse</button>
                        </div>
                        <div class="stats-grid" style="margin-bottom: 20px;">
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Total Rotations</h3>
                                <div class="value" id="resultRotationCount">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Tank Rotation %</h3>
                                <div class="value" id="resultTankRotation">-</div>
                            </div>
                            <div class="stat-card" style="box-shadow: none;">
                                <h3>Rotating on Tank</h3>
                                <div id="resultRotatingOnTank">-</div>
                            </div>
                        </div>
                        <div id="rotationTableContent">
                            <h4 style="color: #8b9dc3; margin-bottom: 15px;">Top Rotation Patterns</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>Pattern</th>
                                        <th>Count</th>
                                        <th>Percentage</th>
                                    </tr>
                                </thead>
                                <tbody id="rotationPatternsBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Cast Sequence -->
                    <div class="table-container" style="margin-bottom: 20px;">
                        <div class="table-header">
                            <div class="table-title">
                                <span>Cast Sequence</span>
                                <span class="filtered-count" id="castCount"></span>
                            </div>
                            <button class="collapse-btn" id="castSequenceCollapseBtn" onclick="toggleCastSequence()">Collapse</button>
                        </div>
                        <div id="castSequenceContent" style="max-height: 500px; overflow-y: auto;">
                            <table>
                                <thead style="position: sticky; top: 0; background: #0f3460;">
                                    <tr>
                                        <th>Time</th>
                                        <th>Spell</th>
                                        <th>Target</th>
                                        <th>Active Tank</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody id="castSequenceBody"></tbody>
                            </table>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Community Theorycrafting Tab -->
        <div id="theorycraftingTab" class="tab-content">
            <div class="container">
                <h1>Community Theorycrafting</h1>

                <div class="notice-banner">
                    <h3>Coming Soon</h3>
                    <p>This section will feature community-driven theorycrafting analyses, discussions, and findings about TBC Restoration Druid optimization.</p>
                </div>
            </div>
        </div>

        <!-- About Tab -->
        <div id="aboutTab" class="tab-content">
            <div class="container">
                <h1>About</h1>

                <div class="about-section">
                    <h2>About Lifebloom</h2>
                    <p>Lifebloom is an application that collects and structures TBC Resto Druid data from WarcraftLogs in order to help facilitate retrospective data analyses by and for the community. This app is still in development in preparation for the next iteration of TBC Classic.</p>
                </div>

                <div class="about-section justified">
                    <h2>Motivation</h2>
                    <p>The Burning Crusade is almost 20 years old!  </p>
                        
                    <p>Despite so much time passing, I don't believe our collective understanding of Resto Druid has progressed significantly since 2007 - and not because the spec has been solved. With TBC Classic, I had hoped that the community would build upon existing knowledge from 2007 and the private server era, but instead what I observed was largely "re-discovery" and recycled guides, and very little theorycrafting or knowledge sharing.</p>
                    <p>To illustrate this, consider the following fundamental questions that I believe remain unanswered:</p>
                    <ul>
                        <li>For a given encounter, is there an optimal spell haste breakpoint?</li>
                        <li>For a given encounter, is there an optimal healing rotation?</li>
                    </ul>
                    <p>These questions appear straightforward, yet after 20 years neither has a definitive answer. Here's my hot take: traditional theorycrafting alone will never solve them.</p>
                    <p>The reason is multifaceted.</p>
                    <p>First, healer theorycrafting is inherently difficult. Raid encounters are complex environments with numerous confounding variables: healer count and composition, fight duration, access to Shadow Priest, etc. The optimal rotation for a 3-minute encounter may differ significantly from a 6-minute encounter due to mana constraints alone.</p>
                    <p>Second, the community is still split on whether HPS is a valid performance metric because of the confounding effects mentioned above. This has left us in a bit of a theorycrafting quagmire - without an objective measure of performance, players instead rely on intuition and subjective arguments about what is good or not. Intuition and experience can get you very far, but different players have different intuitions about what is "best". Layered on top of this is an uncomfortable dogma surrounding the topic of HPS, and just mentioning the word gets you harassed and dogpiled on. I think the community is wrong about HPS.</p>
                    <p>By analyzing large datasets while controlling for confounding variables we can isolate factors that you do have control over - rotation, playstyle, gearing choices, haste breakpoints, etc. across different encounters and conditions. I don't believe these fundamental questions are unanswerable, but we need a new approach. That is the motivation for this tool: combining traditional theorycrafting with data-driven analyses to address fundamental questions and to advance our understanding of the spec.</p>
                </div>

                <div class="about-section author-section justified">
                    <img src="/static/icons/avatar.png" alt="Mercy" class="author-avatar">
                    <div class="author-content">
                        <h2>About the Author</h2>
                        <p>Welcome readers! My name is Mercy (IGN Mercychan) and I've been playing TBC Resto Druid religiously since c. 2017 from the private server era and through TBC Classic. In my opinion TBC was when the class design for Resto Druid was at its best. In my professional life I LARP as a Data Scientist, and I'm hoping to bring together my experience in data science and my passion for this spec in order to help the community push our knowledge of TBC Resto Druid further.</p>
                        <p>If you want to support this project, the best way that you can do that is by using the tool and discussing your insights with the community. The more people become aware of and use this tool for their own analyses, the more we can learn together. If you found the app useful, consider giving the repo a star!</p>
                        <p>If you want to report bugs, request additions to the tool or dataset, or even collab on an analysis, the best way to contact me is via Discord. I'm not always in the community servers but my DMs are open! Feel free to reach out.</p>

                        <div class="contact-links">
                            <a href="https://github.com/msdec321/Lifebloom" target="_blank" class="contact-link">GitHub Repo</a>
                            <a href="https://classic.warcraftlogs.com/character/us/benediction/mercychann?zone=1013&partition=6&metric=hps" target="_blank" class="contact-link">WarcraftLogs</a>
                            <a href="https://www.twitch.tv/mercylolk" target="_blank" class="contact-link">Twitch</a>
                            <span class="contact-link discord">Discord: Mercy9226</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        function switchTab(tabName, updateHash = true) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active from all sidebar tabs
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            if (tabName === 'analysis') {
                document.getElementById('analysisTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(1)').classList.add('active');
                if (updateHash) window.location.hash = 'analysis';
            } else if (tabName === 'report') {
                document.getElementById('reportTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(2)').classList.add('active');
                if (updateHash) window.location.hash = 'report-analyzer';
            } else if (tabName === 'theorycrafting') {
                document.getElementById('theorycraftingTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(3)').classList.add('active');
                if (updateHash) window.location.hash = 'theorycrafting';
            } else if (tabName === 'about') {
                document.getElementById('aboutTab').classList.add('active');
                document.querySelector('.sidebar-tab:nth-child(4)').classList.add('active');
                if (updateHash) window.location.hash = 'about';
            }
        }

        // Handle URL hash on page load and hash change
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (hash === 'report-analyzer' || hash === 'report') {
                switchTab('report', false);
            } else if (hash === 'theorycrafting') {
                switchTab('theorycrafting', false);
            } else if (hash === 'about') {
                switchTab('about', false);
            } else {
                switchTab('analysis', false);
            }
        }

        // Listen for hash changes (back/forward browser buttons)
        window.addEventListener('hashchange', handleHashChange);

        // Chart instances
        let hpsChart = null;
        let hasteChart = null;
        let rotationChart = null;

        // Parse duration string (e.g., "4m 24s") to seconds
        function parseDurationToSeconds(duration) {
            if (!duration) return 0;
            let seconds = 0;
            const minuteMatch = duration.match(/(\d+)m/);
            const secondMatch = duration.match(/(\d+)s/);
            if (minuteMatch) seconds += parseInt(minuteMatch[1]) * 60;
            if (secondMatch) seconds += parseInt(secondMatch[1]);
            return seconds;
        }

        // Helper function to get selected regions
        function getSelectedRegions() {
            const regions = [];
            if (document.getElementById('regionUS').checked) regions.push('US');
            if (document.getElementById('regionEU').checked) regions.push('EU');
            if (document.getElementById('regionCN').checked) regions.push('CN');
            if (document.getElementById('regionKR').checked) regions.push('KR');
            return regions.join(',');
        }

        // Load and update chart with all filtered data
        async function updateChart() {
            const dataset = document.getElementById('dataset').value;
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with all filters but request all data (use high limit)
            let url = `/api/top/10000?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) {
                url += `&totalHealers=${totalHealers}`;
            }
            if (shadowPriest) {
                url += `&vampiricTouch=${shadowPriest}`;
            }
            if (innervates) {
                url += `&innervates=${innervates}`;
            }
            if (rotatingOnTank) {
                url += `&rotatingOnTank=${rotatingOnTank}`;
            }
            if (nDruid) {
                url += `&nDruid=${nDruid}`;
            }
            if (nPaladin) {
                url += `&nPaladin=${nPaladin}`;
            }
            if (nHPriest) {
                url += `&nHPriest=${nHPriest}`;
            }
            if (nDPriest) {
                url += `&nDPriest=${nDPriest}`;
            }
            if (nShaman) {
                url += `&nShaman=${nShaman}`;
            }
            if (regions) {
                url += `&regions=${regions}`;
            }

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;

                const ctx = document.getElementById('hpsChart').getContext('2d');

                // Parse data for chart
                const chartData = data.map(row => ({
                    x: parseDurationToSeconds(row.Duration),
                    y: row.HPS,
                    name: row.Name
                }));

                // Calculate min/max for y-axis
                const hpsValues = chartData.map(d => d.y);
                const minHPS = Math.min(...hpsValues);
                const yAxisMin = Math.max(0, minHPS - 100); // Don't go below 0

                // Destroy existing chart if it exists
                if (hpsChart) {
                    hpsChart.destroy();
                }

                // Create new chart
                hpsChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'HPS vs Duration',
                        data: chartData,
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 1,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = chartData[context.dataIndex];
                                    return `${point.name}: ${point.y.toFixed(2)} HPS at ${point.x}s`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Duration (seconds)',
                                color: '#8b9dc3',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#8b9dc3'
                            },
                            grid: {
                                color: 'rgba(139, 157, 195, 0.1)'
                            }
                        },
                        y: {
                            min: yAxisMin,
                            title: {
                                display: true,
                                text: 'HPS',
                                color: '#8b9dc3',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                color: '#8b9dc3',
                                callback: function(value, index, ticks) {
                                    // Hide the minimum tick value
                                    if (index === 0) {
                                        return '';
                                    }
                                    return value;
                                }
                            },
                            grid: {
                                color: 'rgba(139, 157, 195, 0.1)'
                            }
                        }
                    }
                }
                });
            } catch (error) {
                console.error('Error loading chart data:', error);
            }
        }

        // Load and update Haste chart with all filtered data
        async function updateHasteChart() {
            const dataset = document.getElementById('dataset').value;
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with all filters but request all data (use high limit)
            let url = `/api/top/10000?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) {
                url += `&totalHealers=${totalHealers}`;
            }
            if (shadowPriest) {
                url += `&vampiricTouch=${shadowPriest}`;
            }
            if (innervates) {
                url += `&innervates=${innervates}`;
            }
            if (rotatingOnTank) {
                url += `&rotatingOnTank=${rotatingOnTank}`;
            }
            if (nDruid) {
                url += `&nDruid=${nDruid}`;
            }
            if (nPaladin) {
                url += `&nPaladin=${nPaladin}`;
            }
            if (nHPriest) {
                url += `&nHPriest=${nHPriest}`;
            }
            if (nDPriest) {
                url += `&nDPriest=${nDPriest}`;
            }
            if (nShaman) {
                url += `&nShaman=${nShaman}`;
            }
            if (regions) {
                url += `&regions=${regions}`;
            }

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;

                const ctx = document.getElementById('hasteChart').getContext('2d');

                // Parse data for chart (filter out records with HasteGear = 0)
                const chartData = data
                    .filter(row => row.HasteGear > 0)
                    .map(row => ({
                        x: row.HasteGear,
                        y: row.HPS,
                        name: row.Name
                    }));

                // Calculate binned averages (bins of 50, starting from 100)
                const binSize = 50;
                const binStart = 100;
                const bins = {};

                chartData.forEach(point => {
                    if (point.x >= binStart) {
                        const binIndex = Math.floor((point.x - binStart) / binSize);
                        const binLabel = binStart + binIndex * binSize;
                        if (!bins[binLabel]) {
                            bins[binLabel] = { sum: 0, count: 0, values: [] };
                        }
                        bins[binLabel].sum += point.y;
                        bins[binLabel].count += 1;
                        bins[binLabel].values.push(point.y);
                    }
                });

                // Create sorted bin labels and calculate averages with error bars
                const binLabels = Object.keys(bins).map(Number).sort((a, b) => a - b);
                const binAverages = binLabels.map(label => {
                    const bin = bins[label];
                    const mean = bin.sum / bin.count;

                    // Calculate standard deviation
                    let stdDev = 0;
                    if (bin.count > 1) {
                        const squaredDiffs = bin.values.map(v => Math.pow(v - mean, 2));
                        const variance = squaredDiffs.reduce((a, b) => a + b, 0) / (bin.count - 1);
                        stdDev = Math.sqrt(variance);
                    }

                    // Error = std_dev / sqrt(n) (Standard Error of the Mean)
                    const error = stdDev / Math.sqrt(bin.count);

                    return {
                        x: label + binSize / 2,  // Center of bin
                        y: mean,
                        count: bin.count,
                        binRange: `${label}-${label + binSize - 1}`,
                        error: error,
                        stdDev: stdDev
                    };
                });

                // Calculate min for y-axis
                const hpsValues = chartData.map(d => d.y);
                const minHPS = Math.min(...hpsValues);
                const yAxisMin = Math.max(0, minHPS - 100);

                // Destroy existing chart if it exists
                if (hasteChart) {
                    hasteChart.destroy();
                }

                // Custom plugin for error bars
                const errorBarPlugin = {
                    id: 'errorBars',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const barDataset = chart.data.datasets.find(ds => ds.label === 'Avg HPS by Haste Bin');
                        if (!barDataset) return;

                        const meta = chart.getDatasetMeta(chart.data.datasets.indexOf(barDataset));

                        ctx.save();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.lineWidth = 2;

                        meta.data.forEach((bar, index) => {
                            const dataPoint = binAverages[index];
                            if (dataPoint && dataPoint.error > 0) {
                                const x = bar.x;
                                const yScale = chart.scales.y;
                                const yTop = yScale.getPixelForValue(dataPoint.y + dataPoint.error);
                                const yBottom = yScale.getPixelForValue(dataPoint.y - dataPoint.error);
                                const capWidth = 6;

                                // Vertical line
                                ctx.beginPath();
                                ctx.moveTo(x, yTop);
                                ctx.lineTo(x, yBottom);
                                ctx.stroke();

                                // Top cap
                                ctx.beginPath();
                                ctx.moveTo(x - capWidth, yTop);
                                ctx.lineTo(x + capWidth, yTop);
                                ctx.stroke();

                                // Bottom cap
                                ctx.beginPath();
                                ctx.moveTo(x - capWidth, yBottom);
                                ctx.lineTo(x + capWidth, yBottom);
                                ctx.stroke();
                            }
                        });

                        ctx.restore();
                    }
                };

                // Create new chart
                hasteChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Avg HPS by Haste Bin',
                                type: 'bar',
                                data: binAverages,
                                backgroundColor: 'rgba(255, 159, 64, 0.4)',
                                borderColor: 'rgba(255, 159, 64, 1)',
                                borderWidth: 1,
                                barThickness: 20,
                                order: 2
                            },
                            {
                                label: 'HPS vs Haste',
                                type: 'scatter',
                                data: chartData,
                                backgroundColor: 'rgba(102, 126, 234, 0.6)',
                                borderColor: 'rgba(102, 126, 234, 1)',
                                borderWidth: 1,
                                pointRadius: 5,
                                pointHoverRadius: 7,
                                order: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#8b9dc3'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.dataset.label === 'HPS vs Haste') {
                                            const point = chartData[context.dataIndex];
                                            return `${point.name}: ${point.y.toFixed(2)} HPS at ${point.x} Haste`;
                                        } else {
                                            const bin = binAverages[context.dataIndex];
                                            return `Haste ${bin.binRange}: Avg ${bin.y.toFixed(2)}  ${bin.error.toFixed(2)} HPS (n=${bin.count})`;
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Haste',
                                    color: '#8b9dc3',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    color: '#8b9dc3'
                                },
                                grid: {
                                    color: 'rgba(139, 157, 195, 0.1)'
                                }
                            },
                            y: {
                                min: yAxisMin,
                                title: {
                                    display: true,
                                    text: 'HPS',
                                    color: '#8b9dc3',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    color: '#8b9dc3',
                                    callback: function(value, index, ticks) {
                                        // Hide the minimum tick value
                                        if (index === 0) {
                                            return '';
                                        }
                                        return value;
                                    }
                                },
                                grid: {
                                    color: 'rgba(139, 157, 195, 0.1)'
                                }
                            }
                        }
                    },
                    plugins: [errorBarPlugin]
                });
            } catch (error) {
                console.error('Error loading haste chart data:', error);
            }
        }

        // Load and update Rotation chart with average HPS by primary rotation
        async function updateRotationChart() {
            const dataset = document.getElementById('dataset').value;
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with all filters
            let url = `/api/top/10000?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) url += `&totalHealers=${totalHealers}`;
            if (shadowPriest) url += `&vampiricTouch=${shadowPriest}`;
            if (innervates) url += `&innervates=${innervates}`;
            if (rotatingOnTank) url += `&rotatingOnTank=${rotatingOnTank}`;
            if (nDruid) url += `&nDruid=${nDruid}`;
            if (nPaladin) url += `&nPaladin=${nPaladin}`;
            if (nHPriest) url += `&nHPriest=${nHPriest}`;
            if (nDPriest) url += `&nDPriest=${nDPriest}`;
            if (nShaman) url += `&nShaman=${nShaman}`;
            if (regions) url += `&regions=${regions}`;

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;

                const ctx = document.getElementById('rotationChart').getContext('2d');

                // Group by Rotation1 and calculate averages
                const rotationStats = {};
                data.forEach(row => {
                    const rotation = row.Rotation1;
                    if (rotation && rotation.trim()) {
                        if (!rotationStats[rotation]) {
                            rotationStats[rotation] = { sum: 0, count: 0, values: [] };
                        }
                        rotationStats[rotation].sum += row.HPS;
                        rotationStats[rotation].count += 1;
                        rotationStats[rotation].values.push(row.HPS);
                    }
                });

                // Calculate averages and sort by average HPS descending
                const rotationData = Object.entries(rotationStats)
                    .filter(([_, stats]) => stats.count >= 5)  // Min 5 samples
                    .map(([rotation, stats]) => {
                        const mean = stats.sum / stats.count;
                        let stdDev = 0;
                        if (stats.count > 1) {
                            const squaredDiffs = stats.values.map(v => Math.pow(v - mean, 2));
                            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / (stats.count - 1);
                            stdDev = Math.sqrt(variance);
                        }
                        const error = stdDev / Math.sqrt(stats.count);
                        return {
                            rotation,
                            avg: mean,
                            count: stats.count,
                            error,
                            stdDev
                        };
                    })
                    .sort((a, b) => b.avg - a.avg);

                // Calculate min and max for x-axis
                const minAvgHPS = Math.min(...rotationData.map(d => d.avg));
                const maxAvgHPS = Math.max(...rotationData.map(d => d.avg));
                const xAxisMin = Math.max(0, minAvgHPS - 50);
                const xAxisMax = maxAvgHPS + 50;

                // Destroy existing chart if it exists
                if (rotationChart) {
                    rotationChart.destroy();
                }

                // Custom plugin for error bars on rotation chart
                const rotationErrorBarPlugin = {
                    id: 'rotationErrorBars',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);

                        ctx.save();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.lineWidth = 2;

                        meta.data.forEach((bar, index) => {
                            const dataPoint = rotationData[index];
                            if (dataPoint && dataPoint.error > 0) {
                                const y = bar.y;
                                const xScale = chart.scales.x;
                                const xRight = xScale.getPixelForValue(dataPoint.avg + dataPoint.error);
                                const xLeft = xScale.getPixelForValue(dataPoint.avg - dataPoint.error);
                                const capWidth = 4;

                                // Horizontal line
                                ctx.beginPath();
                                ctx.moveTo(xLeft, y);
                                ctx.lineTo(xRight, y);
                                ctx.stroke();

                                // Left cap
                                ctx.beginPath();
                                ctx.moveTo(xLeft, y - capWidth);
                                ctx.lineTo(xLeft, y + capWidth);
                                ctx.stroke();

                                // Right cap
                                ctx.beginPath();
                                ctx.moveTo(xRight, y - capWidth);
                                ctx.lineTo(xRight, y + capWidth);
                                ctx.stroke();
                            }
                        });

                        ctx.restore();
                    }
                };

                // Create new chart
                rotationChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: rotationData.map(d => d.rotation),
                        datasets: [{
                            label: 'Average HPS',
                            data: rotationData.map(d => d.avg),
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const d = rotationData[context.dataIndex];
                                        return `Avg: ${d.avg.toFixed(2)}  ${d.error.toFixed(2)} HPS (n=${d.count})`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                min: xAxisMin,
                                max: xAxisMax,
                                title: {
                                    display: true,
                                    text: 'Average HPS',
                                    color: '#8b9dc3',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: { color: '#8b9dc3' },
                                grid: { color: 'rgba(139, 157, 195, 0.1)' }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Primary Rotation',
                                    color: '#8b9dc3',
                                    font: { size: 14, weight: 'bold' }
                                },
                                ticks: { color: '#8b9dc3' },
                                grid: { color: 'rgba(139, 157, 195, 0.1)' }
                            }
                        }
                    },
                    plugins: [rotationErrorBarPlugin]
                });
            } catch (error) {
                console.error('Error loading rotation chart data:', error);
            }
        }

        // Toggle chart collapse/expand
        function toggleChart(chartId, button) {
            const chartContent = document.getElementById(chartId + 'Content');

            if (chartContent.classList.contains('collapsed')) {
                chartContent.classList.remove('collapsed');
                chartContent.style.maxHeight = chartContent.scrollHeight + 'px';
                button.textContent = 'Collapse';
            } else {
                chartContent.style.maxHeight = chartContent.scrollHeight + 'px';
                setTimeout(() => {
                    chartContent.classList.add('collapsed');
                }, 10);
                button.textContent = 'Expand';
            }
        }

        // Toggle table collapse/expand
        function toggleTable() {
            const tableContent = document.getElementById('tableContent');
            const collapseBtn = document.getElementById('collapseBtn');

            if (tableContent.classList.contains('collapsed')) {
                tableContent.classList.remove('collapsed');
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
                collapseBtn.textContent = 'Collapse';
            } else {
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
                setTimeout(() => {
                    tableContent.classList.add('collapsed');
                }, 10);
                collapseBtn.textContent = 'Expand';
            }
        }

        // Toggle Data Dictionary collapse/expand
        function toggleDataDictionary() {
            const content = document.getElementById('dataDictContent');
            const btn = document.getElementById('dataDictBtn');

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                btn.textContent = 'Expand';
            } else {
                content.classList.add('expanded');
                btn.textContent = 'Collapse';
            }
        }

        // Update max-height when content changes
        function updateTableHeight() {
            const tableContent = document.getElementById('tableContent');
            if (!tableContent.classList.contains('collapsed')) {
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
            }
        }

        // Global filter state
        let currentFilter = null;

        async function loadTopN() {
            const n = document.getElementById('topN').value || 20;
            const dataset = document.getElementById('dataset').value;
            const dataSource = document.querySelector('input[name="dataSource"]:checked').value;
            const totalHealers = document.getElementById('totalHealers').value;
            const shadowPriest = document.getElementById('shadowPriest').value;
            const innervates = document.getElementById('innervates').value;
            const rotatingOnTank = document.getElementById('rotatingOnTank').value;
            const nDruid = document.getElementById('nDruid').value;
            const nPaladin = document.getElementById('nPaladin').value;
            const nHPriest = document.getElementById('nHPriest').value;
            const nDPriest = document.getElementById('nDPriest').value;
            const nShaman = document.getElementById('nShaman').value;
            const regions = getSelectedRegions();

            // Build URL with optional filters
            let url = `/api/top/${n}?dataset=${dataset}&dataSource=${dataSource}`;
            if (currentFilter !== null) {
                url += `&naturesGrace=${currentFilter}`;
            }
            if (totalHealers) {
                url += `&totalHealers=${totalHealers}`;
            }
            if (shadowPriest) {
                url += `&vampiricTouch=${shadowPriest}`;
            }
            if (innervates) {
                url += `&innervates=${innervates}`;
            }
            if (rotatingOnTank) {
                url += `&rotatingOnTank=${rotatingOnTank}`;
            }
            if (nDruid) {
                url += `&nDruid=${nDruid}`;
            }
            if (nPaladin) {
                url += `&nPaladin=${nPaladin}`;
            }
            if (nHPriest) {
                url += `&nHPriest=${nHPriest}`;
            }
            if (nDPriest) {
                url += `&nDPriest=${nDPriest}`;
            }
            if (nShaman) {
                url += `&nShaman=${nShaman}`;
            }
            if (regions) {
                url += `&regions=${regions}`;
            }

            try {
                const response = await fetch(url);
                const result = await response.json();
                const data = result.data;
                const totalCount = result.total_count;

                const tableBody = document.getElementById('tableBody');

                if (data.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="14" style="text-align: center;">No data available</td></tr>';
                    document.getElementById('filteredCount').textContent = `(0 Filtered Records)`;
                    return;
                }

                tableBody.innerHTML = data.map(row => `
                    <tr>
                        <td>${row.AdjustedRank || 'N/A'}</td>
                        <td><strong>${row.Name || 'N/A'}</strong></td>
                        <td>${row.Server || 'N/A'}</td>
                        <td>${row.Region || 'N/A'}</td>
                        <td>${row.Duration || 'N/A'}</td>
                        <td><strong>${typeof row.HPS === 'number' && !isNaN(row.HPS) ? row.HPS.toFixed(2) : 'N/A'}</strong></td>
                        <td>${typeof row.HasteGear === 'number' && !isNaN(row.HasteGear) && row.HasteGear !== 0 ? row.HasteGear : '-'}</td>
                        <td>${typeof row.Spirit === 'number' && !isNaN(row.Spirit) && row.Spirit !== 0 ? row.Spirit : '-'}</td>
                        <td>${row.TotalHealers || 'N/A'}</td>
                        <td>${typeof row.InnervateCount === 'number' ? row.InnervateCount : 'N/A'}</td>
                        <td>${row.VampiricTouch || 'N/A'}</td>
                        <td>${row.RotatingOnTank || 'N/A'}</td>
                        <td>${row.Rotation1 || 'N/A'}</td>
                        <td>${row.ReportLink ? `<a href="${row.ReportLink}" target="_blank" style="display: inline-block; padding: 6px 12px; background: #2a2d2a; color: #bebeb1; text-decoration: none; border-radius: 4px; font-size: 0.85em; font-weight: 600; border: 1px solid #3a3d3a; transition: all 0.2s;" onmouseover="this.style.background='#3a3d3a'; this.style.color='#fff'" onmouseout="this.style.background='#2a2d2a'; this.style.color='#bebeb1'">View</a>` : 'N/A'}</td>
                    </tr>
                `).join('');

                // Update filtered count with total count from entire filtered dataset
                document.getElementById('filteredCount').textContent = `(${totalCount} Filtered Records)`;

                // Update charts with all filtered data (separate from table)
                updateChart();
                updateHasteChart();
                updateRotationChart();

                // Update table height after loading data
                setTimeout(updateTableHeight, 100);
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('tableBody').innerHTML = '<tr><td colspan="14" style="text-align: center; color: red;">Error loading data</td></tr>';
            }
        }

        // Function to load all data
        function loadData() {
            loadTopN();
        }

        // Function to set filter and update buttons
        function setFilter(filter, buttonId) {
            // Remove active class from all buttons
            document.querySelectorAll('.icon-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // If clicking the same filter, toggle it off
            if (currentFilter === filter) {
                currentFilter = null;
            } else {
                currentFilter = filter;
                // Add active class to clicked button
                if (buttonId) {
                    document.getElementById(buttonId).classList.add('active');
                }
            }

            // Reload data with new filter
            loadTopN();
        }

        // Load data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Handle initial URL hash to show correct tab
            handleHashChange();

            loadData();

            // Add click handlers to icon buttons
            document.getElementById('treeOfLifeBtn').addEventListener('click', () => {
                setFilter('No', 'treeOfLifeBtn');
            });

            document.getElementById('naturesGraceBtn').addEventListener('click', () => {
                setFilter('Yes', 'naturesGraceBtn');
            });

            // Dreamstate button does nothing for now
            document.getElementById('dreamstateBtn').addEventListener('click', () => {
                // No action yet
            });
        });

        // ===== REPORT ANALYZER FUNCTIONS =====

        async function analyzeReport() {
            const reportCode = document.getElementById('reportCode').value.trim();
            const bossName = document.getElementById('bossName').value.trim();
            const playerName = document.getElementById('playerName').value.trim();

            // Validate inputs
            if (!reportCode || !bossName || !playerName) {
                showAnalyzerError('Please fill in all fields: Report Code, Boss Name, and Player Name.');
                return;
            }

            // Show loading, hide results and error
            document.getElementById('analyzerLoading').style.display = 'block';
            document.getElementById('analyzerResults').style.display = 'none';
            document.getElementById('analyzerError').style.display = 'none';
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analyzeBtn').textContent = 'Analyzing...';

            try {
                const response = await fetch('/api/analyze-report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        report_code: reportCode,
                        boss_name: bossName,
                        player_name: playerName
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Analysis failed');
                }

                displayAnalysisResults(data);

            } catch (error) {
                showAnalyzerError(error.message);
            } finally {
                document.getElementById('analyzerLoading').style.display = 'none';
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('analyzeBtn').textContent = 'Analyze';
            }
        }

        function showAnalyzerError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('analyzerError').style.display = 'block';
            document.getElementById('analyzerResults').style.display = 'none';
        }

        function displayAnalysisResults(data) {
            // Show results container
            document.getElementById('analyzerResults').style.display = 'block';

            // Encounter info
            document.getElementById('resultDate').textContent = data.date;
            document.getElementById('resultDuration').textContent = data.duration;
            document.getElementById('resultHealers').textContent = data.total_healers;

            // Player performance
            document.getElementById('resultPlayerName').textContent = data.player_name;
            const ranking = data.player_ranking || {};
            document.getElementById('resultPlayerServer').textContent =
                ranking.server ? `${ranking.server} (${ranking.region})` : 'Unknown Server';

            const hps = ranking.hps || 0;
            document.getElementById('resultHPS').textContent = hps.toFixed(2);
            document.getElementById('resultRank').textContent =
                ranking.rank ? `Rank ${ranking.rank} of ${ranking.totalParses} (${ranking.rankPercent}th percentile)` : '-';

            // Stats
            const stats = data.player_stats || {};
            document.getElementById('resultIntellect').textContent = stats.has_stats ? stats.intellect : '?';
            document.getElementById('resultSpirit').textContent = stats.has_stats ? stats.spirit : '?';
            document.getElementById('resultHaste').textContent = stats.has_stats ? stats.haste_gear : '?';

            // Buffs
            document.getElementById('resultVT').innerHTML = data.has_vampiric_touch
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';
            document.getElementById('resultInnervate').textContent = data.innervate_count;
            document.getElementById('resultBL').innerHTML = data.has_bloodlust
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';
            document.getElementById('resultNG').innerHTML = data.has_natures_grace
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';

            // Trinkets
            const trinkets = data.player_trinkets || {};
            const trinketList = trinkets.trinkets || [];
            document.getElementById('resultTrinket1').textContent =
                trinketList[0] ? `${trinketList[0].name} (ID: ${trinketList[0].id})` : 'Unknown';
            document.getElementById('resultTrinket2').textContent =
                trinketList[1] ? `${trinketList[1].name} (ID: ${trinketList[1].id})` : 'Unknown';

            // HoT Breakdown
            const totalHPS = hps || 1; // avoid division by zero
            document.getElementById('resultLBHPS').textContent = data.lifebloom_hps.toFixed(2);
            document.getElementById('resultLBPercent').textContent = ((data.lifebloom_hps / totalHPS) * 100).toFixed(1) + '%';
            document.getElementById('resultLBUptime').textContent = `${data.lifebloom_uptime_percent}% uptime`;

            document.getElementById('resultRejuvHPS').textContent = data.rejuvenation_hps.toFixed(2);
            document.getElementById('resultRejuvPercent').textContent = ((data.rejuvenation_hps / totalHPS) * 100).toFixed(1) + '%';

            document.getElementById('resultRGHPS').textContent = data.regrowth_total_hps.toFixed(2);
            document.getElementById('resultRGPercent').textContent = ((data.regrowth_total_hps / totalHPS) * 100).toFixed(1) + '%';

            // Regrowth rank breakdown
            const rgRanks = data.regrowth_by_rank || {};
            const rgRankText = Object.entries(rgRanks)
                .filter(([rank, hps]) => hps > 0)
                .map(([rank, hps]) => `R${rank}: ${hps.toFixed(1)}`)
                .join(', ');
            document.getElementById('resultRGRanks').textContent = rgRankText || '-';

            // Healer Composition
            const healerComp = data.healer_composition || {};
            const healerCompHtml = Object.entries(healerComp).map(([type, players]) => {
                const colorClass = type.includes('Druid') ? 'healer-druid'
                    : type.includes('Paladin') ? 'healer-paladin'
                    : type.includes('Holy Priest') ? 'healer-priest-holy'
                    : type.includes('Discipline') ? 'healer-priest-disc'
                    : type.includes('Shaman') ? 'healer-shaman' : '';

                return `
                    <div style="flex: 1; min-width: 150px;">
                        <div style="color: #8b9dc3; font-size: 0.9em; margin-bottom: 5px;">${type} (${players.length})</div>
                        <div class="${colorClass}" style="font-weight: 600;">
                            ${players.length > 0 ? players.join(', ') : 'None'}
                        </div>
                    </div>
                `;
            }).join('');
            document.getElementById('healerCompList').innerHTML = healerCompHtml;

            // Rotation Analysis
            document.getElementById('resultRotationCount').textContent = data.rotation_count;
            document.getElementById('resultTankRotation').textContent = data.tank_rotation_percent + '%';
            document.getElementById('resultRotatingOnTank').innerHTML = data.rotating_on_tank
                ? '<span class="badge badge-yes">Yes</span>'
                : '<span class="badge badge-no">No</span>';

            // Rotation patterns table
            const patterns = data.sorted_patterns || [];
            const totalRotations = data.actual_rotations ? data.actual_rotations.length : 1;
            const patternsHtml = patterns.slice(0, 10).map((pattern, index) => {
                const [notation, count] = pattern;
                const percentage = ((count / totalRotations) * 100).toFixed(1);
                return `
                    <tr>
                        <td>${index + 1}</td>
                        <td><strong>${notation}</strong></td>
                        <td>${count}</td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            }).join('');
            document.getElementById('rotationPatternsBody').innerHTML = patternsHtml || '<tr><td colspan="4">No rotation data</td></tr>';

            // Report link
            document.getElementById('reportLink').href = data.report_link;

            // Cast Sequence with proper rotation grouping using rotation_sections
            const castData = data.cast_data || [];
            const rotationSections = data.rotation_sections || [];
            document.getElementById('castCount').textContent = `(${castData.length} casts)`;

            // Check if a section is "interesting" (same logic as actual_rotations filter in Python)
            function isInterestingSection(section) {
                // Filter out: [1LB 0I 0RG] (just rotation start) and [0LB 1I 0RG] (just instant cast)
                const isJustRotationStart = (section.lb === 1 && section.i === 0 && section.rg === 0);
                const isJustInstantCast = (section.lb === 0 && section.i === 1 && section.rg === 0);
                return !isJustRotationStart && !isJustInstantCast;
            }

            // Function to find which section a cast belongs to based on time
            function findSectionIndex(time) {
                for (let i = 0; i < rotationSections.length; i++) {
                    const section = rotationSections[i];
                    // For last section, include end_time; otherwise exclude it
                    const isLastSection = (i === rotationSections.length - 1);
                    if (time >= section.start_time && (isLastSection ? time <= section.end_time : time < section.end_time)) {
                        return i;
                    }
                }
                return -1;
            }

            let lastSectionIndex = -1;
            let displayedRotationNumber = 0;
            const castSequenceHtml = castData.map((cast, index) => {
                // Find which section this cast belongs to
                const sectionIndex = findSectionIndex(cast.time);

                // Skip casts from uninteresting sections entirely
                if (sectionIndex >= 0 && !isInterestingSection(rotationSections[sectionIndex])) {
                    return '';  // Don't render this cast
                }

                // Determine action string
                let actionStr = '';
                if (cast.rotation_start) {
                    actionStr = '<span style="color: #10b981; font-weight: 600;">Rotation started</span>';
                } else if (cast.instant_cast) {
                    actionStr = 'Instant cast';
                } else if (cast.regrowth) {
                    actionStr = 'Regrowth';
                } else {
                    actionStr = '-';
                }

                // Highlight lifebloom on tank
                const spellStyle = cast.rotation_start ? 'color: #10b981; font-weight: 600;' : '';

                let separatorRow = '';

                // Add separator when entering a new section
                if (sectionIndex !== lastSectionIndex && sectionIndex >= 0) {
                    displayedRotationNumber++;
                    const section = rotationSections[sectionIndex];
                    const notation = `[${section.lb}LB ${section.i}I ${section.rg}RG]`;
                    separatorRow = `
                        <tr style="background: #0f3460; border-top: 2px solid #667eea;">
                            <td colspan="5" style="padding: 8px; color: #667eea; font-weight: 600; text-align: center;">
                                Rotation #${displayedRotationNumber} &nbsp;&nbsp; ${notation}
                            </td>
                        </tr>
                    `;
                    lastSectionIndex = sectionIndex;
                }

                return `
                    ${separatorRow}
                    <tr>
                        <td>${cast.time.toFixed(2)}s</td>
                        <td style="${spellStyle}">${cast.spell}</td>
                        <td>${cast.target}</td>
                        <td style="color: #C41E3A;">${cast.active_tank}</td>
                        <td>${actionStr}</td>
                    </tr>
                `;
            }).join('');
            document.getElementById('castSequenceBody').innerHTML = castSequenceHtml || '<tr><td colspan="5">No cast data</td></tr>';
        }

        function toggleRotationTable() {
            const content = document.getElementById('rotationTableContent');
            const btn = content.previousElementSibling.previousElementSibling.querySelector('.collapse-btn');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = 'Collapse';
            } else {
                content.style.display = 'none';
                btn.textContent = 'Expand';
            }
        }

        function toggleCastSequence() {
            const content = document.getElementById('castSequenceContent');
            const btn = document.getElementById('castSequenceCollapseBtn');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = 'Collapse';
            } else {
                content.style.display = 'none';
                btn.textContent = 'Expand';
            }
        }

        // Allow Enter key to submit the form
        document.addEventListener('DOMContentLoaded', function() {
            ['reportCode', 'bossName', 'playerName'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            analyzeReport();
                        }
                    });
                }
            });
        });
    </script>
</body>
</html>
